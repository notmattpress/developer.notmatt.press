
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled Page</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@3.3.5/dist/tailwind.min.css" rel="stylesheet">
    <style>
        body {
            background-color: white;
            color: black;
            font-family: 'Quicksand', 'Open Sans', 'Helvetica', 'Arial', san-serif;
        }
        a, h1, h2, h3, h4, h5, h6 {
            color: #0073aa;
        }
        .container {
            max-width: 800px;
            margin: auto;
            padding: 20px;
        }
        .has-small-font-size.is-link-to-top {
            position: absolute;
            bottom: 10px;
            right: 10px;
        }
        .entry-content {
            position:relative;
        }
        .entry-content img {
            max-width: 100%;
        }
    </style>
</head>
<body>
<div class='container'>
    
    <div class="page-metadata" data-published="" data-last-updated=""></div>
    
    <div aria-label="Breadcrumbs" class="wp-block-wporg-site-breadcrumbs has-small-font-size" role="navigation"><div class="wporg-site-breadcrumbs__wrapper"><span><a href="https://developer.wordpress.org">Home</a></span><span><a href="https://developer.wordpress.org/block-editor/">Block Editor Handbook</a></span><span><a href="https://developer.wordpress.org/block-editor/reference-guides/">Reference Guides</a></span><span><a href="https://developer.wordpress.org/block-editor/reference-guides/interactivity-api/">Interactivity API Reference</a></span><span><a href="https://developer.wordpress.org/block-editor/reference-guides/interactivity-api/core-concepts/">Core Concepts</a></span><span class="is-current-page">Understanding global state, local context and derived state</span></div></div>  <!-- Full breadcrumbs HTML -->
    <h1>Understanding global state, local context and derived state</h1>
    
    
    <div class="content"><div class="entry-content wp-block-post-content is-layout-flow wp-block-post-content-is-layout-flow"><p>The Interactivity API offers a powerful framework for creating interactive blocks. To make the most of its capabilities, it’s crucial to understand when to use global state, local context, or derived state. This guide will clarify these concepts and provide practical examples to help you decide when to use each one.</p>
<p>Let’s start with a brief definition of global state, local context and derived state.</p>
<ul>
<li><strong>Global state:</strong> Global data that can be accessed and modified by any interactive block on the page, allowing different parts of your interactive blocks to stay in sync.</li>
<li><strong>Local context:</strong> Local data defined within a specific element in the HTML structure, accessible only to that element and its children, providing independent state for individual blocks.</li>
<li><strong>Derived state:</strong> Computed values based on global state or local context, dynamically calculated on-demand to ensure consistent data representation without storing redundant data.</li>
</ul>
<p>Let’s now dive into each of these concepts to study them in more detail and provide some examples.</p>
<h2 class="is-toc-heading" id="global-state" tabindex="-1"><a href="#global-state">Global state</a></h2>
<p><strong>Global state</strong> in the Interactivity API refers to global data that can be accessed and modified by any interactive block on the page. It serves as a shared information hub, allowing different parts of your blocks to communicate and stay in sync. Global state is the ideal mechanism for exchanging information between interactive blocks, regardless of their position in the DOM tree.</p>
<p>You should use global state when:</p>
<ul>
<li>You need to share data between multiple interactive blocks that are not directly related in the DOM hierarchy.</li>
<li>You want to maintain a single source of truth for certain data across all your interactive blocks.</li>
<li>You’re dealing with data that affects multiple parts of your UI simultaneously.</li>
<li>You want to implement features that are global for the page.</li>
</ul>
<h3 class="is-toc-heading" id="working-with-global-state" tabindex="-1"><a href="#working-with-global-state">Working with global state</a></h3>
<ul>
<li><strong>Initializing the global state</strong>
<p>Typically, the initial global state values should be defined on the server using the <code>wp_interactivity_state</code> function:</p>
<pre><code class="language-php">// Populates the initial global state values.
wp_interactivity_state( 'myPlugin', array(
  'isDarkTheme' =&gt; true,
  'show'        =&gt; false,
  'helloText'   =&gt; __( 'world' ),
));
</code></pre>
<p>These initial global state values will be used during the rendering of the page in PHP to populate the HTML markup that is sent to the browser.</p>
<ul>
<li>HTML markup written in the PHP file by the developer:
<pre><code class="language-html">&lt;div
    data-wp-interactive="myPlugin"
    data-wp-class--is-dark-theme="state.isDarkTheme"
    class="my-plugin"
&gt;
    &lt;div data-wp-bind--hidden="!state.show"&gt;
        Hello &lt;span data-wp-text="state.helloText"&gt;&lt;/span&gt;
    &lt;/div&gt;
    &lt;button data-wp-on-async--click="actions.toggle"&gt;Toggle&lt;/button&gt;
&lt;/div&gt;
</code></pre>
</li>
<li>HTML markup after the directives have been processed and it is ready to be sent to the browser:
<pre><code class="language-html">&lt;div
    data-wp-interactive="myPlugin"
    data-wp-class--is-dark-theme="state.isDarkTheme"
    class="my-plugin is-dark-theme"
&gt;
    &lt;div hidden data-wp-bind--hidden="!state.show"&gt;
        Hello &lt;span data-wp-text="state.helloText"&gt;world&lt;/span&gt;
    &lt;/div&gt;
    &lt;button data-wp-on-async--click="actions.toggle"&gt;Toggle&lt;/button&gt;
&lt;/div&gt;
</code></pre>
</li>
</ul>
<p><em>Please, visit <a href="https://developer.notmatt.press/block-editor/reference-guides/interactivity-api/core-concepts/server-side-rendering/">the Server-side Rendering guide</a> to learn more about how directives are processed on the server.</em></p>
<p>In cases where the global state is not used during the rendering of the page in PHP, it can also be defined directly on the client.</p>
<pre><code class="language-js">const { state } = store( 'myPlugin', {
    state: {
        isLoading: false,
    },
    actions: {
        *loadSomething() {
            state.isLoading = true;
            // ...
        },
    },
} );
</code></pre>
<p><em>Please note that, although this works, in general it is a good practice to define all the global state on the server.</em></p>
</li>
<li>
<p><strong>Accessing the global state</strong></p>
<p>In the HTML markup, you can access the global state values directly by referencing <code>state</code> in the directive attribute values:</p>
<pre><code class="language-html">&lt;div data-wp-bind--hidden="!state.show"&gt;
    &lt;span data-wp-text="state.helloText"&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>In JavaScript, the <code>store</code> function from the package at <code>@wordpress/interactivity</code> works both as a setter and a getter, returning the store of the selected namespace.</p>
<p>To access the global state in your actions and callbacks, you can use the <code>state</code> property of the object returned by the <code>store</code> function:</p>
<pre><code class="language-js">const myPluginStore = store( 'myPlugin' );

myPluginStore.state; // This is the state of the 'myPlugin' namespace.
</code></pre>
<p>You can also destructure the object returned by <code>store</code>:</p>
<pre><code class="language-js">const { state } = store( 'myPlugin' );
</code></pre>
<p>And you can do the same even if you are defining the store at that moment, which is the most common scenario:</p>
<pre><code class="language-js">const { state } = store( 'myPlugin', {
    state: {
        // ...
    },
    actions: {
        toggle() {
            state.show = ! state.show;
        },
    },
} );
</code></pre>
<p>The global state initialized on the server using the <code>wp_interactivity_state</code> function is also included in that object because it is automatically serialized from the server to the client:</p>
<pre><code class="language-php">wp_interactivity_state( 'myPlugin', array(
  'someValue' =&gt; 1,
));
</code></pre>
<pre><code class="language-js">const { state } = store( 'myPlugin', {
    state: {
        otherValue: 2,
    },
    actions: {
        readGlobalState() {
            state.someValue; // It exists and its initial value is 1.
            state.otherValue; // It exists and its initial value is 2.
        },
    },
} );
</code></pre>
<p>Lastly, all calls to the <code>store</code> function with the same namespace are merged together:</p>
<pre><code class="language-js">store( 'myPlugin', { state: { someValue: 1 } } );

store( 'myPlugin', { state: { otherValue: 2 } } );

/* All calls to `store` return a stable reference to the same object, so you
 * can get a reference to `state` from any of them. */
const { state } = store( 'myPlugin' );

store( 'myPlugin', {
    actions: {
        readValues() {
            state.someValue; // It exists and its initial value is 1.
            state.otherValue; // It exists and its initial value is 2.
        },
    },
} );
</code></pre>
</li>
<li><strong>Updating the global state</strong>
<p>To update the global state, all you need to do is mutate the <code>state</code> object once you have obtained it from the <code>store</code> function:</p>
<pre><code class="language-js">const { state } = store( 'myPlugin', {
    actions: {
        updateValues() {
            state.someValue = 3;
            state.otherValue = 4;
        },
    },
} );
</code></pre>
<p>Changes to the global state will automatically trigger updates in any directives that depend on the modified values.</p>
<p><em>Please, visit <a href="https://developer.notmatt.press/block-editor/reference-guides/interactivity-api/core-concepts/the-reactive-and-declarative-mindset/">The Reactive and Declarative mindset</a> guide to learn more about how reactivity works in the Interactivity API.</em></p>
</li>
</ul>
<h3 class="is-toc-heading" id="example-two-interactive-blocks-using-global-state-to-communicate" tabindex="-1"><a href="#example-two-interactive-blocks-using-global-state-to-communicate">Example: Two interactive blocks using global state to communicate</a></h3>
<p>In this example, there are two independent interactive blocks. One displays a counter, and the other a button to increment that counter. These blocks can be positioned anywhere on the page, regardless of the HTML structure. In other words, one does not need to be an inner block of the other.</p>
<ul>
<li><strong>Counter Block</strong>
<pre><code class="language-php">&lt;?php
wp_interactivity_state( 'myCounterPlugin', array(
  'counter' =&gt; 0
));
?&gt;

&lt;div
  data-wp-interactive="myCounterPlugin"
  &lt;?php echo get_block_wrapper_attributes(); ?&gt;
&gt;
  Counter: &lt;span data-wp-text="state.counter"&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre>
</li>
<li><strong>Increment Block</strong>
<pre><code class="language-php">&lt;div
  data-wp-interactive="myCounterPlugin"
  &lt;?php echo get_block_wrapper_attributes(); ?&gt;
&gt;
  &lt;button data-wp-on-async--click="actions.increment"&gt;
    Increment
  &lt;/button&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">const { state } = store( 'myCounterPlugin', {
    actions: {
        increment() {
            state.counter += 1;
        },
    },
} );
</code></pre>
</li>
</ul>
<p>In this example:</p>
<ol>
<li>The global state is initialized on the server using <code>wp_interactivity_state</code>, setting an initial <code>counter</code> of 0.</li>
<li>The Counter Block displays the current counter using <code>data-wp-text="state.counter"</code>, which reads from the global state.</li>
<li>The Increment Block contains a button that triggers the <code>increment</code> action when clicked, using <code>data-wp-on-async--click="actions.increment"</code>.</li>
<li>In JavaScript, the <code>increment</code> action directly modifies the global state by incrementing <code>state.counter</code>.</li>
</ol>
<p>Both blocks are independent and can be placed anywhere on the page. They don’t need to be nested or directly related in the DOM structure. Multiple instances of these interactive blocks can be added to the page, and they will all share and update the same global counter value.</p>
<h2 class="is-toc-heading" id="local-context" tabindex="-1"><a href="#local-context">Local context</a></h2>
<p><strong>Local context</strong> in the Interactivity API refers to local data defined within a specific element in the HTML structure. Unlike global state, local context is only accessible to the element where it’s defined and its child elements.</p>
<p>The local context is particularly useful when you need independent state for individual interactive blocks, ensuring that each instance of a block can maintain its own unique data without interfering with others.</p>
<p>You should use local context when:</p>
<ul>
<li>You need to maintain separate state for multiple instances of the same interactive block.</li>
<li>You want to encapsulate data that’s only relevant to a specific interactive block and its children.</li>
<li>You need to implement features that are isolated to a specific part of your UI.</li>
</ul>
<h3 class="is-toc-heading" id="working-with-local-context" tabindex="-1"><a href="#working-with-local-context">Working with local context</a></h3>
<ul>
<li><strong>Initializing the local context</strong>
<p>The local context is initialized directly within the HTML structure using the <code>data-wp-context</code> directive. This directive accepts a JSON string that defines the initial values for that piece of context.</p>
<pre><code class="language-html">&lt;div data-wp-context='{ "counter": 0 }'&gt;
    &lt;!-- Child elements will have access to `context.counter` --&gt;
&lt;/div&gt;
</code></pre>
<p>You can also initialize the local context on the server using the <code>wp_interactivity_data_wp_context</code> PHP helper, which ensures proper escaping and formatting of the stringified values:</p>
<pre><code class="language-php">&lt;?php
$context = array( 'counter' =&gt; 0 );
?&gt;

&lt;div &lt;?php echo wp_interactivity_data_wp_context( $context ); ?&gt;&gt;
  &lt;!-- Child elements will have access to `context.counter` --&gt;
&lt;/div&gt;
</code></pre>
</li>
<li><strong>Accessing the local context</strong>
<p>In the HTML markup, you can access the local context values directly by referencing <code>context</code> in the directive values:</p>
<pre><code class="language-html">&lt;div data-wp-bind--hidden="!context.isOpen"&gt;
    &lt;span data-wp-text="context.counter"&gt;&lt;/span&gt;
&lt;/div&gt;
</code></pre>
<p>In JavaScript, you can access the local context values using the <code>getContext</code> function:</p>
<pre><code class="language-js">store( 'myPlugin', {
    actions: {
        sendAnalyticsEvent() {
            const { counter } = getContext();
            myAnalyticsLibrary.sendEvent( 'updated counter', counter );
        },
    },
    callbacks: {
        logCounter() {
            const { counter } = getContext();
            console.log( `Current counter: ${ counter }` );
        },
    },
} );
</code></pre>
<p>The <code>getContext</code> function returns the local context of the element that triggered the action/callback execution.</p>
</li>
<li>
<p><strong>Updating the local context</strong></p>
<p>To update the local context values in JavaScript, you can modify the object returned by <code>getContext</code>:</p>
<pre><code class="language-js">store( 'myPlugin', {
    actions: {
        increment() {
            const context = getContext();
            context.counter += 1;
        },
        updateName( event ) {
            const context = getContext();
            context.name = event.target.value;
        },
    },
} );
</code></pre>
<p>Changes to the local context will automatically trigger updates in any directives that depend on the modified values.</p>
<p><em>Please, visit <a href="https://developer.notmatt.press/block-editor/reference-guides/interactivity-api/core-concepts/the-reactive-and-declarative-mindset/">The Reactive and Declarative mindset</a> guide to learn more about how reactivity works in the Interactivity API.</em></p>
</li>
<li>
<p><strong>Nesting local contexts</strong></p>
<p>Local contexts can be nested, with child contexts inheriting and potentially overriding values from parent contexts:</p>
<pre><code class="language-html">&lt;div data-wp-context='{ "theme": "light", "counter": 0 }'&gt;
    &lt;p&gt;Theme: &lt;span data-wp-text="context.theme"&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;Counter: &lt;span data-wp-text="context.counter"&gt;&lt;/span&gt;&lt;/p&gt;

    &lt;div data-wp-context='{ "theme": "dark" }'&gt;
        &lt;p&gt;Theme: &lt;span data-wp-text="context.theme"&gt;&lt;/span&gt;&lt;/p&gt;
        &lt;p&gt;Counter: &lt;span data-wp-text="context.counter"&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>In this example, the inner <code>div</code> will have a <code>theme</code> value of <code>"dark"</code>, but will inherit the <code>counter</code> value <code>0</code> from its parent context.</p>
</li>
</ul>
<h3 class="is-toc-heading" id="example-one-interactive-block-using-local-context-to-have-independent-state" tabindex="-1"><a href="#example-one-interactive-block-using-local-context-to-have-independent-state">Example: One interactive block using local context to have independent state</a></h3>
<p>In this example, there is a single interactive block that shows a counter and can increment it. By using local context, each instance of this block will have its own independent counter, even if multiple blocks are added to the page.</p>
<pre><code class="language-php">&lt;div
  data-wp-interactive="myCounterPlugin"
  &lt;?php echo get_block_wrapper_attributes(); ?&gt;
  data-wp-context='{ "counter": 0 }'
&gt;
  &lt;p&gt;Counter: &lt;span data-wp-text="context.counter"&gt;&lt;/span&gt;&lt;/p&gt;
  &lt;button data-wp-on-async--click="actions.increment"&gt;Increment&lt;/button&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">store( 'myCounterPlugin', {
    actions: {
        increment() {
            const context = getContext();
            context.counter += 1;
        },
    },
} );
</code></pre>
<p>In this example:</p>
<ol>
<li>A local context with an initial <code>counter</code> value of <code>0</code> is defined using the <code>data-wp-context</code> directive.</li>
<li>The counter is displayed using <code>data-wp-text="context.counter"</code>, which reads from the local context.</li>
<li>The increment button uses <code>data-wp-on-async--click="actions.increment"</code> to trigger the increment action.</li>
<li>In JavaScript, the <code>getContext</code> function is used to access and modify the local context for each block instance.</li>
</ol>
<p>A user will be able to add multiple instances of this block to a page, and each will maintain its own independent counter. Clicking the “Increment” button on one block will only affect that specific block’s counter and not the others.</p>
<h2 class="is-toc-heading" id="derived-state" tabindex="-1"><a href="#derived-state">Derived state</a></h2>
<p><strong>Derived state</strong> in the Interactivity API refers to a value that is computed from other parts of the global state or local context. It’s calculated on demand rather than stored. It ensures consistency, reduces redundancies, and enhances the declarative nature of your code.</p>
<p>Derived state is a fundamental concept in modern state management, not unique to the Interactivity API. It’s also used in other popular state management systems like Redux, where it’s called <code>selectors</code>, or Preact Signals, where it’s known as <code>computed</code> values.</p>
<p>Derived state offers several key benefits that make it an essential part of a well-designed application state, including:</p>
<ol>
<li><strong>Single source of truth:</strong> Derived state encourages you to store only the essential, raw data in your state. Any values that can be calculated from this core data become derived state. This approach reduces the risk of inconsistencies in your interactive blocks.
</li>
<li>
<p><strong>Automatic updates:</strong> When you use derived state, values are recalculated automatically whenever the underlying data changes. This ensures that all parts of your interactive blocks always have access to the most up-to-date information without manual intervention.</p>
</li>
<li>
<p><strong>Simplified state management:</strong> By computing values on-demand rather than storing and updating them manually, you reduce the complexity of your state management logic. This leads to cleaner, more maintainable code.</p>
</li>
<li>
<p><strong>Improved performance:</strong> In many cases, derived state can be optimized to recalculate only when necessary, potentially improving your interactive blocks’ performance.</p>
</li>
<li>
<p><strong>Easier debugging:</strong> With derived state, it’s clearer where data originates and how it’s transformed. This can make it easier to track down issues in your interactive blocks.</p>
</li>
</ol>
<p>In essence, derived state allows you to express relationships between different pieces of data in your interactive blocks declaratively, instead of imperatively updating related values whenever something changes.</p>
<p><em>Please, visit <a href="https://developer.notmatt.press/block-editor/reference-guides/interactivity-api/core-concepts/the-reactive-and-declarative-mindset/">The Reactive and Declarative mindset</a> guide to learn more about how to leverage declarative coding in the Interactivity API.</em></p>
<p>You should use derived state:</p>
<ul>
<li>When a part of your global state or local context can be computed from other state values.</li>
<li>To avoid redundant data that needs to be manually kept in sync.</li>
<li>To ensure consistency across your interactive blocks by automatically updating derived values.</li>
<li>To simplify your actions by removing the need to update multiple related state properties.</li>
</ul>
<h3 class="is-toc-heading" id="working-with-derived-state" tabindex="-1"><a href="#working-with-derived-state">Working with derived state</a></h3>
<ul>
<li><strong>Initializing the derived state</strong>
<p>Typically, the derived state should be initialized on the server using the <code>wp_interactivity_state</code> function in the exact same way as the global state.</p>
<ul>
<li>When the initial value is known and static, it can be defined directly:
<pre><code class="language-php">wp_interactivity_state( 'myCounterPlugin', array(
  'counter' =&gt; 1, // This is global state.
  'double'  =&gt; 2, // This is derived state.
));
</code></pre>
</li>
<li>Or it can be defined by doing the necessary computations:
<pre><code class="language-php">$counter = 1;
$double  = $counter * 2;

wp_interactivity_state( 'myCounterPlugin', array(
  'counter' =&gt; $counter, // This is global state.
  'double'  =&gt; $double,  // This is derived state.
));
</code></pre>
</li>
</ul>
<p>Regardless of the approach, the initial derived state values will be used during the rendering of the page in PHP, and the HTML can be populated with the correct values.</p>
<p><em>Please, visit <a href="https://developer.notmatt.press/block-editor/reference-guides/interactivity-api/core-concepts/server-side-rendering/">the Server-side Rendering guide</a> to learn more about how directives are processed on the server.</em></p>
<p>The same mechanism applies even when the derived state property depends on the local context.</p>
<pre><code class="language-php">&lt;?php
$counter = 1;

// This is the local context.
$context = array( 'counter' =&gt; $counter );

wp_interactivity_state( 'myCounterPlugin', array(
  'double' =&gt; $counter * 2, // This is derived state.
));
?&gt;

&lt;div
  data-wp-interactive="myCounterPlugin"
  &lt;?php echo wp_interactivity_data_wp_context( $context ); ?&gt;
&gt;
  &lt;div&gt;
    Counter: &lt;span data-wp-text="context.counter"&gt;&lt;/span&gt;
  &lt;/div&gt;
  &lt;div&gt;
    Double: &lt;span data-wp-text="state.double"&gt;&lt;/span&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>In JavaScript, the derived state is defined using getters:</p>
<pre><code class="language-js">const { state } = store( 'myCounterPlugin', {
    state: {
        get double() {
            return state.counter * 2;
        },
    },
} );
</code></pre>
<p>Derived state can depend on local context, or local context and global state at the same time.</p>
<pre><code class="language-js">const { state } = store( 'myCounterPlugin', {
    state: {
        get double() {
            const { counter } = getContext();
            // Depends on local context.
            return counter * 2;
        },
        get product() {
            const { counter } = getContext();
            // Depends on local context and global state.
            return counter * state.factor;
        },
    },
} );
</code></pre>
<p>In some cases, when the derived state depends on the local context and the local context can change dynamically in the server, instead of the initial derived state, you can use a function (Closure) that calculates it dynamically.</p>
<pre><code class="language-php">&lt;?php
wp_interactivity_state( 'myProductPlugin', array(
  'list'    =&gt; array( 1, 2, 3 ),
  'factor'  =&gt; 3,
  'product' =&gt; function() {
    $state   = wp_interactivity_state();
    $context = wp_interactivity_get_context();
    return $context['item'] * $state['factor'];
  }
));
?&gt;

&lt;template
  data-wp-interactive="myProductPlugin"
  data-wp-each="state.list"
&gt;
  &lt;span data-wp-text="state.product"&gt;&lt;/span&gt;
&lt;/template&gt;
</code></pre>
<p>This <code>data-wp-each</code> template will render this HTML (directives omitted):</p>
<pre><code class="language-html">&lt;span&gt;3&lt;/span&gt;
&lt;span&gt;6&lt;/span&gt;
&lt;span&gt;9&lt;/span&gt;
</code></pre>
</li>
<li><strong>Accessing the derived state</strong>
<p>In the HTML markup, the syntax for the derived state is the same as the one for the global state, just by referencing <code>state</code> in the directive attribute values.</p>
<pre><code class="language-html">&lt;span data-wp-text="state.double"&gt;&lt;/span&gt;
</code></pre>
<p>The same happens in JavaScript. Both global state and derived state can be consumed through the <code>state</code> property of the store:</p>
<pre><code class="language-js">const { state } = store( 'myCounterPlugin', {
    // ...
    actions: {
        readValues() {
            state.counter; // Regular state, returns 1.
            state.double; // Derived state, returns 2.
        },
    },
} );
</code></pre>
<p>This lack of distinction is intentional, allowing developers to consume both derived and global state uniformly, and making them interchangeable in practice.</p>
<p>You can also access the derived state from another derived state and, thus, create multiple levels of computed values.</p>
<pre><code class="language-js">const { state } = store( 'myPlugin', {
    state: {
        get double() {
            return state.counter * 2;
        },
        get doublePlusOne() {
            return state.double + 1;
        },
    },
} );
</code></pre>
</li>
<li><strong>Updating the derived state</strong>
<p>The derived state cannot be updated directly. To update its values, you need to update the global state or local context on which that derived state depends.</p>
<pre><code class="language-js">const { state } = store( 'myCounterPlugin', {
    // ...
    actions: {
        updateValues() {
            state.counter; // Regular state, returns 1.
            state.double; // Derived state, returns 2.

            state.counter = 2;

            state.counter; // Regular state, returns 2.
            state.double; // Derived state, returns 4.
        },
    },
} );
</code></pre>
</li>
</ul>
<h3 class="is-toc-heading" id="example-not-using-derived-state-vs-using-derived-state" tabindex="-1"><a href="#example-not-using-derived-state-vs-using-derived-state">Example: Not using derived state vs using derived state</a></h3>
<p>Let’s consider a scenario where there is a counter and the double value needs to be displayed, and let’s compare two approaches: one without derived state and one with derived state.</p>
<ul>
<li><strong>Not using derived state</strong>
<pre><code class="language-js">const { state } = store( 'myCounterPlugin', {
    state: {
        counter: 1,
        double: 2,
    },
    actions: {
        increment() {
            state.counter += 1;
            state.double = state.counter * 2;
        },
    },
} );
</code></pre>
<p>In this approach, both the <code>state.counter</code> and <code>state.double</code> values are manually updated in the <code>increment</code> action. While this works, it has several drawbacks:</p>
<ul>
<li>It’s less declarative.</li>
<li>It can lead to bugs if <code>state.counter</code> is updated from multiple places and developers forget to keep <code>state.double</code> in sync.</li>
<li>It requires more cognitive load to remember to update related values.</li>
</ul>
</li>
<li><strong>Using derived state</strong>
<pre><code class="language-js">const { state } = store( 'myCounterPlugin', {
    state: {
        counter: 1,
        get double() {
            return state.counter * 2;
        },
    },
    actions: {
        increment() {
            state.counter += 1;
        },
    },
} );
</code></pre>
<p>In this improved version:</p>
<ul>
<li><code>state.double</code> is defined as a getter, automatically deriving its value from <code>state.counter</code>.</li>
<li>The <code>increment</code> action only needs to update <code>state.counter</code>.</li>
<li><code>state.double</code> is always guaranteed to have the correct value, regardless of how or where <code>state.counter</code> is updated.</li>
</ul>
</li>
</ul>
<h3 class="is-toc-heading" id="example-using-derived-state-with-local-context" tabindex="-1"><a href="#example-using-derived-state-with-local-context">Example: Using derived state with local context</a></h3>
<p>Let’s now consider a scenario where there is a local context that initializes a counter.</p>
<pre><code class="language-js">store( 'myCounterPlugin', {
    state: {
        get double() {
            const { counter } = getContext();
            return counter * 2;
        },
    },
    actions: {
        increment() {
            const context = getContext();
            context.counter += 1;
        },
    },
} );
</code></pre>
<pre><code class="language-html">&lt;div data-wp-interactive="myCounterPlugin"&gt;
    &lt;!-- This will render "Double: 2" --&gt;
    &lt;div data-wp-context='{ "counter": 1 }'&gt;
        Double: &lt;span data-wp-text="state.double"&gt;&lt;/span&gt;

        &lt;!-- This button will increment the local counter. --&gt;
        &lt;button data-wp-on-async--click="actions.increment"&gt;Increment&lt;/button&gt;
    &lt;/div&gt;

    &lt;!-- This will render "Double: 4" --&gt;
    &lt;div data-wp-context='{ "counter": 2 }'&gt;
        Double: &lt;span data-wp-text="state.double"&gt;&lt;/span&gt;

        &lt;!-- This button will increment the local counter. --&gt;
        &lt;button data-wp-on-async--click="actions.increment"&gt;Increment&lt;/button&gt;
    &lt;/div&gt;
&lt;/div&gt;
</code></pre>
<p>In this example, the derived state <code>state.double</code> reads from the local context present in each element and returns the correct value for each instance where it is used.</p>
<h3 class="is-toc-heading" id="example-using-derived-state-with-both-local-context-and-global-state" tabindex="-1"><a href="#example-using-derived-state-with-both-local-context-and-global-state">Example: Using derived state with both local context and global state</a></h3>
<p>Let’s now consider a scenario where there is a global tax rate and local product prices and calculate the final price, including tax.</p>
<pre><code class="language-html">&lt;div
    data-wp-interactive="myProductPlugin"
    data-wp-context='{ "priceWithoutTax": 100 }'
&gt;
    &lt;p&gt;Product Price: $&lt;span data-wp-text="context.priceWithoutTax"&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;Tax Rate: &lt;span data-wp-text="state.taxRatePercentage"&gt;&lt;/span&gt;&lt;/p&gt;
    &lt;p&gt;Price (inc. tax): $&lt;span data-wp-text="state.priceWithTax"&gt;&lt;/span&gt;&lt;/p&gt;
&lt;/div&gt;
</code></pre>
<pre><code class="language-js">const { state } = store( 'myProductPlugin', {
    state: {
        taxRate: 0.21,
        get taxRatePercentage() {
            return `${ state.taxRate * 100 }%`;
        },
        get priceWithTax() {
            const { priceWithoutTax } = getContext();
            return price * ( 1 + state.taxRate );
        },
    },
    actions: {
        updateTaxRate( event ) {
            // Updates the global tax rate.
            state.taxRate = event.target.value;
        },
        updatePrice( event ) {
            // Updates the local product price.
            const context = getContext();
            context.priceWithoutTax = event.target.value;
        },
    },
} );
</code></pre>
<p>In this example, <code>priceWithTax</code> is derived from both the global <code>taxRate</code> and the local <code>priceWithoutTax</code>. Every time you update the global state or local context through the <code>updateTaxRate</code> or <code>updatePrice</code> actions, the Interactivity API recomputes the derived state and updates the necessary parts of the DOM.</p>
<p>By using derived state, you create a more maintainable and less error-prone codebase. It ensures that related state values are always in sync, reduces the complexity of your actions, and makes your code more declarative and easier to reason about.</p>
<h2 class="is-toc-heading" id="subscribing-to-server-state-and-context" tabindex="-1"><a href="#subscribing-to-server-state-and-context">Subscribing to Server State and Context</a></h2>
<p>Interactivity API offers a region-based navigation feature that dynamically replaces a part of the page without a full page reload. The <a href="https://developer.notmatt.press/block-editor/reference-guides/core-blocks/#query-loop">Query block</a> natively supports this feature when the <code>Force page reload</code> toggle is disabled. Developers can use the same functionality in custom blocks by calling <a href="https://developer.notmatt.press/block-editor/reference-guides/packages/packages-interactivity-router/#actions"><code>actions.navigate()</code></a> from the <a href="https://github.com/WordPress/gutenberg/tree/trunk/packages/interactivity-router"><code>@wordpress/interactivity-router</code></a> script module.</p>
<p>When using region-based navigation, it’s crucial to ensure that your interactive blocks stay in sync with the server-provided global state and local context. By default, the Interactivity API will never overwrite the global state or local context with the server-provided values. The Interactivity API provides two functions to help manage this synchronization: <a href="https://developer.notmatt.press/block-editor/reference-guides/interactivity-api/api-reference/#getserverstate"><code>getServerState()</code></a> and <a href="https://developer.notmatt.press/block-editor/reference-guides/interactivity-api/api-reference/#getservercontext"><code>getServerContext()</code></a>.</p>
<h3 class="is-toc-heading" id="getserverstate" tabindex="-1"><a href="#getserverstate">getServerState()</a></h3>
<p><code>getServerState()</code> allows you to subscribe to changes in the <strong>global state</strong> that occur during client-side navigation. This function is analogous to <code>getServerContext()</code>, but it works with the global state instead of the local context.</p>
<p>The <code>getServerState()</code> function returns a read-only reactive object. This means that any <a href="https://developer.notmatt.press/block-editor/reference-guides/interactivity-api/api-reference/#accessing-data-in-callbacks">callbacks</a> you have defined that watch the returned object will only trigger when the value returned by the function changes. If the value remains the same, the callback will not re-trigger.</p>
<p>Let’s consider a quiz that has multiple questions. Each question is a separate page. When the user navigates to a new question, the server provides the new question and the time left to answer all the questions.</p>
<pre><code class="language-php">&lt;div &lt;?php echo wp_interactivity_state( 'myPlugin', array(
    'question' =&gt; get_question_for_page( get_the_ID() ),
    'timeLeft' =&gt; 5 * 60, // Time to answer all the questions.
) ); ?&gt;&gt;
</code></pre>
<pre><code class="language-javascript">import { store, getServerState } from '@wordpress/interactivity';

store( 'myPlugin', {
    actions: {
        // This action would be triggered by a directive, like:
        // &lt;button data-wp-on-click="actions.nextQuestion"&gt;Next Question&lt;/button&gt;
        *nextQuestion() {
            event.preventDefault( event );
            const { actions } = yield import(
                '@wordpress/interactivity-router'
            );
            actions.navigate( '/question-2' );
        },
    },
    callbacks: {
        // This callback would be triggered by a directive, like:
        // &lt;div data-wp-watch="callbacks.updateQuestion"&gt;&lt;/div&gt;
        updateQuestion() {
            const serverState = getServerState();

            // Update with the new value coming from the server.
            // We DON'T want to update `timeLeft` because it represents the time left to answer ALL the questions.
            state.question = serverState.question;
        },
    },
} );
</code></pre>
<h3 class="is-toc-heading" id="getservercontext" tabindex="-1"><a href="#getservercontext">getServerContext()</a></h3>
<p><code>getServerContext()</code> allows you to subscribe to changes in the <strong>local context</strong> that occur during client-side navigation. This function is analogous to <code>getServerState()</code>, but it works with the local context instead of the global state.</p>
<p>The <code>getServerContext()</code> function returns a read-only reactive object. This means that any <a href="https://developer.notmatt.press/block-editor/reference-guides/interactivity-api/api-reference/#accessing-data-in-callbacks">callbacks</a> you have defined that watch the returned object will only trigger when the value returned by the function changes. If the value remains the same, the callback will not re-trigger.</p>
<p>Consider a quiz that has multiple questions. Each question is a separate page. When the user navigates to a new question, the server provides the new question and the time left to answer all the questions.</p>
<pre><code class="language-php">&lt;div &lt;?php echo wp_interactivity_data_wp_context( array(
    'currentQuestion' =&gt; get_question_for_page( get_the_ID() ),
), ); ?&gt;&gt;
</code></pre>
<pre><code class="language-javascript">import { store, getServerContext } from '@wordpress/interactivity';

store( 'myPlugin', {
    actions: {
        // This action would be triggered by a directive, like:
        // &lt;button data-wp-on-click="actions.nextQuestion"&gt;Next Question&lt;/button&gt;
        *nextQuestion() {
            event.preventDefault( event );
            const { actions } = yield import(
                '@wordpress/interactivity-router'
            );
            actions.navigate( '/question-2' );
        },
    },
    callbacks: {
        // This callback would be triggered by a directive, like:
        // &lt;div data-wp-watch="callbacks.updateQuestion"&gt;&lt;/div&gt;
        updateQuestion() {
            const serverContext = getServerContext();
            const context = getContext();

            // Update with the new value coming from the server.
            context.currentQuestion = serverContext.currentQuestion;
        },
    },
} );
</code></pre>
<h3 class="is-toc-heading" id="when-to-use" tabindex="-1"><a href="#when-to-use">When to Use</a></h3>
<p>Whenever you have interactive blocks that rely on global state or local context that may change due to navigation events, ensuring consistency across different parts of your application.</p>
<h3 class="is-toc-heading" id="best-practices-for-using-getserverstate-and-getservercontext" tabindex="-1"><a href="#best-practices-for-using-getserverstate-and-getservercontext">Best Practices for using getServerState() and getServerContext()</a></h3>
<ul>
<li><strong>Read-Only References:</strong> Both <code>getServerState()</code> and <code>getServerContext()</code> return read-only objects. You can use those objects to update the global state or local context.</li>
<li><strong>Callback Integration:</strong> Incorporate these functions within your store <a href="https://developer.notmatt.press/block-editor/reference-guides/interactivity-api/api-reference/#accessing-data-in-callbacks">callbacks</a> to react to state and context changes. Both <code>getServerState()</code> and <code>getServerContext()</code> return reactive objects. This means that their watch callbacks will only trigger when the value of a property changes. If the value remains the same, the callback will not re-trigger.</li>
</ul>
<h2 class="is-toc-heading" id="conclusion" tabindex="-1"><a href="#conclusion">Conclusion</a></h2>
<p>Remember, the key to effective state management is to keep your state minimal and avoid redundancy. Use derived state to compute values dynamically, and choose between global state and local context based on the scope and requirements of your data. This will lead to a cleaner, more robust architecture that is easier to debug and maintain. Finally, if you need to synchronize the state or context with the server, you can use <code>getServerState()</code> and <code>getServerContext()</code> to achieve this.</p>
</div></div>
    </div>
<footer class="text-center mt-10 py-5">
    <p class="text-sm"><a href="https://notmatt.press">NotMattPress</a>.</p>
</footer>
</body>
</html>
