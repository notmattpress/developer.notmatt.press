
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled Page</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@3.3.5/dist/tailwind.min.css" rel="stylesheet">
    <style>
        body {
            background-color: white;
            color: black;
            font-family: 'Quicksand', 'Open Sans', 'Helvetica', 'Arial', san-serif;
        }
        a, h1, h2, h3, h4, h5, h6 {
            color: #0073aa;
        }
        .container {
            max-width: 800px;
            margin: auto;
            padding: 20px;
        }
        .has-small-font-size.is-link-to-top {
            position: absolute;
            bottom: 10px;
            right: 10px;
        }
        .entry-content {
            position:relative;
        }
        .entry-content img {
            max-width: 100%;
        }
    </style>
</head>
<body>
<div class='container'>
    
    <div class="page-metadata" data-published="" data-last-updated=""></div>
    
    <div aria-label="Breadcrumbs" class="wp-block-wporg-site-breadcrumbs has-small-font-size" role="navigation"><div class="wporg-site-breadcrumbs__wrapper"><span><a href="https://developer.wordpress.org">Home</a></span><span><a href="https://developer.wordpress.org/reference/">Reference</a></span><span><a href="https://developer.wordpress.org/reference/classes/">Classes</a></span><span><a href="https://developer.wordpress.org/reference/classes/wp_html_processor/">WP_HTML_Processor</a></span><span class="is-current-page">WP_HTML_Processor::step_in_body()</span></div></div>  <!-- Full breadcrumbs HTML -->
    <h1>WP_HTML_Processor::step_in_body()</h1>
    <h1 class="wp-block-wporg-code-reference-title" style="margin-bottom:40px;">WP_HTML_Processor::step_in_body(): <span class="return-type">bool</span></h1>
    <div class='notice'>This function’s access is marked private. This means it is not intended for use by plugin or theme developers, only in other core functions. It is listed here for completeness. Usehttps://html.spec.whatwg.org/#parsing-main-inbodyinstead.</div>
    <div class="content"><div class="entry-content wp-block-post-content is-layout-flow wp-container-core-post-content-is-layout-1 wp-block-post-content-is-layout-flow">
<section class="wp-block-wporg-code-reference-summary"><p>Parses next element in the ‘in body’ insertion mode.</p>
</section>
<section class="wp-block-wporg-code-reference-description"><h2 class="is-toc-heading wp-block-heading has-heading-5-font-size" id="description" tabindex="-1"><a href="#description">Description</a></h2> <p>This internal function performs the ‘in body’ insertion mode logic for the generalized <a href="https://developer.notmatt.press/reference/classes/wp_html_processor/step/" rel="method">WP_HTML_Processor::step()</a> function.</p>
<h3 class="is-toc-heading has-heading-5-font-size" id="see-also" tabindex="-1"><a href="#see-also">See also</a></h3><ul><li><a href="https://html.spec.whatwg.org/#parsing-main-inbody">https://html.spec.whatwg.org/#parsing-main-inbody</a></li>
<li><a href="https://developer.notmatt.press/reference/classes/WP_HTML_Processor/step">WP_HTML_Processor::step</a></li>
</ul></section>
<section class="wporg-has-embedded-code wp-block-wporg-code-reference-return-value"><h2 class="is-toc-heading wp-block-heading has-heading-5-font-size" id="return" tabindex="-1"><a href="#return">Return</a></h2> <span class="return-type">bool</span> Whether an element was found.</section>
<section class="wp-block-wporg-code-reference-source"><h2 class="is-toc-heading wp-block-heading has-heading-5-font-size" id="source" tabindex="-1"><a href="#source">Source</a></h2> <pre aria-label="Function source code" class="wp-block-code" data-start="882"><code class="language-php line-numbers" id="wporg-source-code" lang="php">				'#text' === $token_name
			)
		) ||
		(
			'math' === $adjusted_current_node-&gt;namespace &amp;&amp;
			'ANNOTATION-XML' === $adjusted_current_node-&gt;node_name &amp;&amp;
			$is_start_tag &amp;&amp; 'SVG' === $token_name
		) ||
		(
			'html' === $adjusted_current_node-&gt;integration_node_type &amp;&amp;
			( $is_start_tag || '#text' === $token_name )
		)
	);

	try {
		if ( ! $parse_in_current_insertion_mode ) {
			return $this-&gt;step_in_foreign_content();
		}

		switch ( $this-&gt;state-&gt;insertion_mode ) {
			case WP_HTML_Processor_State::INSERTION_MODE_INITIAL:
				return $this-&gt;step_initial();

			case WP_HTML_Processor_State::INSERTION_MODE_BEFORE_HTML:
				return $this-&gt;step_before_html();

			case WP_HTML_Processor_State::INSERTION_MODE_BEFORE_HEAD:
				return $this-&gt;step_before_head();

			case WP_HTML_Processor_State::INSERTION_MODE_IN_HEAD:
				return $this-&gt;step_in_head();

			case WP_HTML_Processor_State::INSERTION_MODE_IN_HEAD_NOSCRIPT:
				return $this-&gt;step_in_head_noscript();

			case WP_HTML_Processor_State::INSERTION_MODE_AFTER_HEAD:
				return $this-&gt;step_after_head();

			case WP_HTML_Processor_State::INSERTION_MODE_IN_BODY:
				return $this-&gt;step_in_body();

			case WP_HTML_Processor_State::INSERTION_MODE_IN_TABLE:
				return $this-&gt;step_in_table();

			case WP_HTML_Processor_State::INSERTION_MODE_IN_TABLE_TEXT:
				return $this-&gt;step_in_table_text();

			case WP_HTML_Processor_State::INSERTION_MODE_IN_CAPTION:
				return $this-&gt;step_in_caption();

			case WP_HTML_Processor_State::INSERTION_MODE_IN_COLUMN_GROUP:
				return $this-&gt;step_in_column_group();

			case WP_HTML_Processor_State::INSERTION_MODE_IN_TABLE_BODY:
				return $this-&gt;step_in_table_body();

			case WP_HTML_Processor_State::INSERTION_MODE_IN_ROW:
				return $this-&gt;step_in_row();

			case WP_HTML_Processor_State::INSERTION_MODE_IN_CELL:
				return $this-&gt;step_in_cell();

			case WP_HTML_Processor_State::INSERTION_MODE_IN_SELECT:
				return $this-&gt;step_in_select();

			case WP_HTML_Processor_State::INSERTION_MODE_IN_SELECT_IN_TABLE:
				return $this-&gt;step_in_select_in_table();

			case WP_HTML_Processor_State::INSERTION_MODE_IN_TEMPLATE:
				return $this-&gt;step_in_template();

			case WP_HTML_Processor_State::INSERTION_MODE_AFTER_BODY:
				return $this-&gt;step_after_body();

			case WP_HTML_Processor_State::INSERTION_MODE_IN_FRAMESET:
				return $this-&gt;step_in_frameset();

			case WP_HTML_Processor_State::INSERTION_MODE_AFTER_FRAMESET:
				return $this-&gt;step_after_frameset();

			case WP_HTML_Processor_State::INSERTION_MODE_AFTER_AFTER_BODY:
				return $this-&gt;step_after_after_body();

			case WP_HTML_Processor_State::INSERTION_MODE_AFTER_AFTER_FRAMESET:
				return $this-&gt;step_after_after_frameset();

			// This should be unreachable but PHP doesn't have total type checking on switch.
			default:
				$this-&gt;bail( "Unaware of the requested parsing mode: '{$this-&gt;state-&gt;insertion_mode}'." );
		}
	} catch ( WP_HTML_Unsupported_Exception $e ) {
		/*
		 * Exceptions are used in this class to escape deep call stacks that
		 * otherwise might involve messier calling and return conventions.
		 */
		return false;
	}
}

/**
 * Computes the HTML breadcrumbs for the currently-matched node, if matched.
 *
 * Breadcrumbs start at the outermost parent and descend toward the matched element.
 * They always include the entire path from the root HTML node to the matched element.
 *
 * @todo It could be more efficient to expose a generator-based version of this function
 *       to avoid creating the array copy on tag iteration. If this is done, it would likely
 *       be more useful to walk up the stack when yielding instead of starting at the top.
 *
 * Example
 *
 *     $processor = WP_HTML_Processor::create_fragment( '&lt;p&gt;&lt;strong&gt;&lt;em&gt;&lt;img&gt;&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;' );
 *     $processor-&gt;next_tag( 'IMG' );
 *     $processor-&gt;get_breadcrumbs() === array( 'HTML', 'BODY', 'P', 'STRONG', 'EM', 'IMG' );
 *
 * @since 6.4.0
 *
 * @return string[]|null Array of tag names representing path to matched node, if matched, otherwise NULL.
 */
public function get_breadcrumbs(): ?array {
	return $this-&gt;breadcrumbs;
}

/**
 * Returns the nesting depth of the current location in the document.
 *
 * Example:
 *
 *     $processor = WP_HTML_Processor::create_fragment( '&lt;div&gt;&lt;p&gt;&lt;/p&gt;&lt;/div&gt;' );
 *     // The processor starts in the BODY context, meaning it has depth from the start: HTML &gt; BODY.
 *     2 === $processor-&gt;get_current_depth();
 *
 *     // Opening the DIV element increases the depth.
 *     $processor-&gt;next_token();
 *     3 === $processor-&gt;get_current_depth();
 *
 *     // Opening the P element increases the depth.
 *     $processor-&gt;next_token();
 *     4 === $processor-&gt;get_current_depth();
 *
 *     // The P element is closed during `next_token()` so the depth is decreased to reflect that.
 *     $processor-&gt;next_token();
 *     3 === $processor-&gt;get_current_depth();
 *
 * @since 6.6.0
 *
 * @return int Nesting-depth of current location in the document.
 */
public function get_current_depth(): int {
	return count( $this-&gt;breadcrumbs );
}

/**
 * Normalizes an HTML fragment by serializing it.
 *
 * This method assumes that the given HTML snippet is found in BODY context.
 * For normalizing full documents or fragments found in other contexts, create
 * a new processor using <a href="https://developer.notmatt.press/reference/classes/WP_HTML_Processor/create_fragment">WP_HTML_Processor::create_fragment</a> or
 * <a href="https://developer.notmatt.press/reference/classes/WP_HTML_Processor/create_full_parser">WP_HTML_Processor::create_full_parser</a> and call <a href="https://developer.notmatt.press/reference/classes/WP_HTML_Processor/serialize">WP_HTML_Processor::serialize</a>
 * on the created instances.
 *
 * Many aspects of an input HTML fragment may be changed during normalization.
 *
 *  - Attribute values will be double-quoted.
 *  - Duplicate attributes will be removed.
 *  - Omitted tags will be added.
 *  - Tag and attribute name casing will be lower-cased,
 *    except for specific SVG and MathML tags or attributes.
 *  - Text will be re-encoded, null bytes handled,
 *    and invalid UTF-8 replaced with U+FFFD.
 *  - Any incomplete syntax trailing at the end will be omitted,
 *    for example, an unclosed comment opener will be removed.
 *
 * Example:
 *
 *     echo WP_HTML_Processor::normalize( '&lt;a href=#anchor v=5 href="/" enabled&gt;One&lt;/a another v=5&gt;&lt;!--' );
 *     // &lt;a href="#anchor" v="5" enabled&gt;One&lt;/a&gt;
 *
 *     echo WP_HTML_Processor::normalize( '&lt;div&gt;&lt;/p&gt;fun&lt;table&gt;&lt;td&gt;cell&lt;/div&gt;' );
 *     // &lt;div&gt;&lt;p&gt;&lt;/p&gt;fun&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;cell&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
 *
 *     echo WP_HTML_Processor::normalize( '&lt;![CDATA[invalid comment]]&gt; syntax &lt; &lt;&gt; "oddities"' );
 *     // &lt;!--[CDATA[invalid comment]]--&gt; syntax &amp;lt; &amp;lt;&amp;gt; &amp;quot;oddities&amp;quot;
 *
 * @since 6.7.0
 *
 * @param string $html Input HTML to normalize.
 *
 * @return string|null Normalized output, or `null` if unable to normalize.
 */
public static function normalize( string $html ): ?string {
	return static::create_fragment( $html )-&gt;serialize();
}

/**
 * Returns normalized HTML for a fragment by serializing it.
 *
 * This differs from <a href="https://developer.notmatt.press/reference/classes/WP_HTML_Processor/normalize">WP_HTML_Processor::normalize</a> in that it starts with
 * a specific HTML Processor, which _must_ not have already started scanning;
 * it must be in the initial ready state and will be in the completed state once
 * serialization is complete.
 *
 * Many aspects of an input HTML fragment may be changed during normalization.
 *
 *  - Attribute values will be double-quoted.
 *  - Duplicate attributes will be removed.
 *  - Omitted tags will be added.
 *  - Tag and attribute name casing will be lower-cased,
 *    except for specific SVG and MathML tags or attributes.
 *  - Text will be re-encoded, null bytes handled,
 *    and invalid UTF-8 replaced with U+FFFD.
 *  - Any incomplete syntax trailing at the end will be omitted,
 *    for example, an unclosed comment opener will be removed.
 *
 * Example:
 *
 *     $processor = WP_HTML_Processor::create_fragment( '&lt;a href=#anchor v=5 href="/" enabled&gt;One&lt;/a another v=5&gt;&lt;!--' );
 *     echo $processor-&gt;serialize();
 *     // &lt;a href="#anchor" v="5" enabled&gt;One&lt;/a&gt;
 *
 *     $processor = WP_HTML_Processor::create_fragment( '&lt;div&gt;&lt;/p&gt;fun&lt;table&gt;&lt;td&gt;cell&lt;/div&gt;' );
 *     echo $processor-&gt;serialize();
 *     // &lt;div&gt;&lt;p&gt;&lt;/p&gt;fun&lt;table&gt;&lt;tbody&gt;&lt;tr&gt;&lt;td&gt;cell&lt;/td&gt;&lt;/tr&gt;&lt;/tbody&gt;&lt;/table&gt;&lt;/div&gt;
 *
 *     $processor = WP_HTML_Processor::create_fragment( '&lt;![CDATA[invalid comment]]&gt; syntax &lt; &lt;&gt; "oddities"' );
 *     echo $processor-&gt;serialize();
 *     // &lt;!--[CDATA[invalid comment]]--&gt; syntax &amp;lt; &amp;lt;&amp;gt; &amp;quot;oddities&amp;quot;
 *
 * @since 6.7.0
 *
 * @return string|null Normalized HTML markup represented by processor,
 *                     or `null` if unable to generate serialization.
 */
public function serialize(): ?string {
	if ( WP_HTML_Tag_Processor::STATE_READY !== $this-&gt;parser_state ) {
		wp_trigger_error(
			__METHOD__,
			'An HTML Processor which has already started processing cannot serialize its contents. Serialize immediately after creating the instance.',
			E_USER_WARNING
		);
		return null;
	}

	$html = '';
	while ( $this-&gt;next_token() ) {
		$html .= $this-&gt;serialize_token();
	}

	if ( null !== $this-&gt;get_last_error() ) {
		wp_trigger_error(
			__METHOD__,
			"Cannot serialize HTML Processor with parsing error: {$this-&gt;get_last_error()}.",
			E_USER_WARNING
		);
		return null;
	}

	return $html;
}

/**
 * Serializes the currently-matched token.
 *
 * This method produces a fully-normative HTML string for the currently-matched token,
 * if able. If not matched at any token or if the token doesn't correspond to any HTML
 * it will return an empty string (for example, presumptuous end tags are ignored).
 *
 * @see static::serialize()
 *
 * @since 6.7.0
 *
 * @return string Serialization of token, or empty string if no serialization exists.
 */
protected function serialize_token(): string {
	$html       = '';
	$token_type = $this-&gt;get_token_type();

	switch ( $token_type ) {
		case '#text':
			$html .= htmlspecialchars( $this-&gt;get_modifiable_text(), ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML5, 'UTF-8' );
			break;

		// Unlike the `&lt;&gt;` which is interpreted as plaintext, this is ignored entirely.
		case '#presumptuous-tag':
			break;

		case '#funky-comment':
		case '#comment':
			$html .= "&lt;!--{$this-&gt;get_full_comment_text()}--&gt;";
			break;

		case '#cdata-section':
			$html .= "&lt;![CDATA[{$this-&gt;get_modifiable_text()}]]&gt;";
			break;

		case 'html':
			$html .= '&lt;!DOCTYPE html&gt;';
			break;
	}

	if ( '#tag' !== $token_type ) {
		return $html;
	}

	$tag_name       = str_replace( "\x00", "\u{FFFD}", $this-&gt;get_tag() );
	$in_html        = 'html' === $this-&gt;get_namespace();
	$qualified_name = $in_html ? strtolower( $tag_name ) : $this-&gt;get_qualified_tag_name();

	if ( $this-&gt;is_tag_closer() ) {
		$html .= "&lt;/{$qualified_name}&gt;";
		return $html;
	}

	$attribute_names = $this-&gt;get_attribute_names_with_prefix( '' );
	if ( ! isset( $attribute_names ) ) {
		$html .= "&lt;{$qualified_name}&gt;";
		return $html;
	}

	$html .= "&lt;{$qualified_name}";
	foreach ( $attribute_names as $attribute_name ) {
		$html .= " {$this-&gt;get_qualified_attribute_name( $attribute_name )}";
		$value = $this-&gt;get_attribute( $attribute_name );

		if ( is_string( $value ) ) {
			$html .= '="' . htmlspecialchars( $value, ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML5 ) . '"';
		}

		$html = str_replace( "\x00", "\u{FFFD}", $html );
	}

	if ( ! $in_html &amp;&amp; $this-&gt;has_self_closing_flag() ) {
		$html .= ' /';
	}

	$html .= '&gt;';

	// Flush out self-contained elements.
	if ( $in_html &amp;&amp; in_array( $tag_name, array( 'IFRAME', 'NOEMBED', 'NOFRAMES', 'SCRIPT', 'STYLE', 'TEXTAREA', 'TITLE', 'XMP' ), true ) ) {
		$text = $this-&gt;get_modifiable_text();

		switch ( $tag_name ) {
			case 'IFRAME':
			case 'NOEMBED':
			case 'NOFRAMES':
				$text = '';
				break;

			case 'SCRIPT':
			case 'STYLE':
				break;

			default:
				$text = htmlspecialchars( $text, ENT_QUOTES | ENT_SUBSTITUTE | ENT_HTML5, 'UTF-8' );
		}

		$html .= "{$text}&lt;/{$qualified_name}&gt;";
	}

	return $html;
}

/**
 * Parses next element in the 'initial' insertion mode.
 *
 * This internal function performs the 'initial' insertion mode
 * logic for the generalized WP_HTML_Processor::step() function.
 *
 * @since 6.7.0
 *
 * @throws WP_HTML_Unsupported_Exception When encountering unsupported HTML input.
 *
 * @see https://html.spec.whatwg.org/#the-initial-insertion-mode
 * @see WP_HTML_Processor::step
 *
 * @return bool Whether an element was found.
 */
private function step_initial(): bool {
	$token_name = $this-&gt;get_token_name();
	$token_type = $this-&gt;get_token_type();
	$op_sigil   = '#tag' === $token_type ? ( parent::is_tag_closer() ? '-' : '+' ) : '';
	$op         = "{$op_sigil}{$token_name}";

	switch ( $op ) {
		/*
		 * &gt; A character token that is one of U+0009 CHARACTER TABULATION,
		 * &gt; U+000A LINE FEED (LF), U+000C FORM FEED (FF),
		 * &gt; U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
		 *
		 * Parse error: ignore the token.
		 */
		case '#text':
			if ( parent::TEXT_IS_WHITESPACE === $this-&gt;text_node_classification ) {
				return $this-&gt;step();
			}
			goto initial_anything_else;
			break;

		/*
		 * &gt; A comment token
		 */
		case '#comment':
		case '#funky-comment':
		case '#presumptuous-tag':
			$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
			return true;

		/*
		 * &gt; A DOCTYPE token
		 */
		case 'html':
			$doctype = $this-&gt;get_doctype_info();
			if ( null !== $doctype &amp;&amp; 'quirks' === $doctype-&gt;indicated_compatability_mode ) {
				$this-&gt;compat_mode = WP_HTML_Tag_Processor::QUIRKS_MODE;
			}

			/*
			 * &gt; Then, switch the insertion mode to "before html".
			 */
			$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_BEFORE_HTML;
			$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
			return true;
	}

	/*
	 * &gt; Anything else
	 */
	initial_anything_else:
	$this-&gt;compat_mode           = WP_HTML_Tag_Processor::QUIRKS_MODE;
	$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_BEFORE_HTML;
	return $this-&gt;step( self::REPROCESS_CURRENT_NODE );
}

/**
 * Parses next element in the 'before html' insertion mode.
 *
 * This internal function performs the 'before html' insertion mode
 * logic for the generalized WP_HTML_Processor::step() function.
 *
 * @since 6.7.0
 *
 * @throws WP_HTML_Unsupported_Exception When encountering unsupported HTML input.
 *
 * @see https://html.spec.whatwg.org/#the-before-html-insertion-mode
 * @see WP_HTML_Processor::step
 *
 * @return bool Whether an element was found.
 */
private function step_before_html(): bool {
	$token_name = $this-&gt;get_token_name();
	$token_type = $this-&gt;get_token_type();
	$is_closer  = parent::is_tag_closer();
	$op_sigil   = '#tag' === $token_type ? ( $is_closer ? '-' : '+' ) : '';
	$op         = "{$op_sigil}{$token_name}";

	switch ( $op ) {
		/*
		 * &gt; A DOCTYPE token
		 */
		case 'html':
			// Parse error: ignore the token.
			return $this-&gt;step();

		/*
		 * &gt; A comment token
		 */
		case '#comment':
		case '#funky-comment':
		case '#presumptuous-tag':
			$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
			return true;

		/*
		 * &gt; A character token that is one of U+0009 CHARACTER TABULATION,
		 * &gt; U+000A LINE FEED (LF), U+000C FORM FEED (FF),
		 * &gt; U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
		 *
		 * Parse error: ignore the token.
		 */
		case '#text':
			if ( parent::TEXT_IS_WHITESPACE === $this-&gt;text_node_classification ) {
				return $this-&gt;step();
			}
			goto before_html_anything_else;
			break;

		/*
		 * &gt; A start tag whose tag name is "html"
		 */
		case '+HTML':
			$this-&gt;insert_html_element( $this-&gt;state-&gt;current_token );
			$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_BEFORE_HEAD;
			return true;

		/*
		 * &gt; An end tag whose tag name is one of: "head", "body", "html", "br"
		 *
		 * Closing BR tags are always reported by the Tag Processor as opening tags.
		 */
		case '-HEAD':
		case '-BODY':
		case '-HTML':
			/*
			 * &gt; Act as described in the "anything else" entry below.
			 */
			goto before_html_anything_else;
			break;
	}

	/*
	 * &gt; Any other end tag
	 */
	if ( $is_closer ) {
		// Parse error: ignore the token.
		return $this-&gt;step();
	}

	/*
	 * &gt; Anything else.
	 *
	 * &gt; Create an html element whose node document is the Document object.
	 * &gt; Append it to the Document object. Put this element in the stack of open elements.
	 * &gt; Switch the insertion mode to "before head", then reprocess the token.
	 */
	before_html_anything_else:
	$this-&gt;insert_virtual_node( 'HTML' );
	$this-&gt;state-&gt;insertion_mode = WP_HTML_Processor_State::INSERTION_MODE_BEFORE_HEAD;
	return $this-&gt;step( self::REPROCESS_CURRENT_NODE );
}

/**
 * Parses next element in the 'before head' insertion mode.
 *
 * This internal function performs the 'before head' insertion mode
 * logic for the generalized WP_HTML_Processor::step() function.
 *
 * @since 6.7.0 Stub implementation.
 *
 * @throws WP_HTML_Unsupported_Exception When encountering unsupported HTML input.
 *
 * @see https://html.spec.whatwg.org/#the-before-head-insertion-mode
 * @see WP_HTML_Processor::step
 *
 * @return bool Whether an element was found.
 */
private function step_before_head(): bool {
	$token_name = $this-&gt;get_token_name();
	$token_type = $this-&gt;get_token_type();
	$is_closer  = parent::is_tag_closer();
	$op_sigil   = '#tag' === $token_type ? ( $is_closer ? '-' : '+' ) : '';
	$op         = "{$op_sigil}{$token_name}";

	switch ( $op ) {
		/*
		 * &gt; A character token that is one of U+0009 CHARACTER TABULATION,
		 * &gt; U+000A LINE FEED (LF), U+000C FORM FEED (FF),
		 * &gt; U+000D CARRIAGE RETURN (CR), or U+0020 SPACE
		 *
		 * Parse error: ignore the token.
		 */
		case '#text':
			if ( parent::TEXT_IS_WHITESPACE === $this-&gt;text_node_classification ) {
				return $this-&gt;step();
			}
			goto before_head_anything_else;
			break;

		/*
</code></pre><p class="wporg-dot-link-list"><a href="https://developer.notmatt.press/reference/files/wp-includes/html-api/class-wp-html-processor.php/">View all references</a> <a href="https://core.trac.wordpress.org/browser/tags/6.7/src/wp-includes/html-api/class-wp-html-processor.php#L882">View on Trac</a> <a href="https://github.com/WordPress/wordpress-develop/blob/6.7/src/wp-includes/html-api/class-wp-html-processor.php#L882-L1449">View on GitHub</a></p></section>
<section class="wp-block-wporg-code-reference-changelog"><h2 class="is-toc-heading wp-block-heading has-heading-5-font-size" id="changelog" tabindex="-1"><a href="#changelog">Changelog</a></h2> <section class="wp-block-wporg-code-table" style="margin-top:var(--wp--preset--spacing--20);"><figure class="wp-block-table"><table><thead><tr><th scope="col">Version</th><th scope="col">Description</th></tr></thead><tbody><tr class=""><td><a href="https://developer.notmatt.press/reference/since/6.4.0/">6.4.0</a></td><td>Introduced.</td></tr></tbody></table></figure></section> </section>
</div></div>
    </div>
<footer class="text-center mt-10 py-5">
    <p class="text-sm"><a href="https://notmatt.press">NotMattPress</a>.</p>
</footer>
</body>
</html>
