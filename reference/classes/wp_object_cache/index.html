
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled Page</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@3.3.5/dist/tailwind.min.css" rel="stylesheet">
    <style>
        body {
            background-color: white;
            color: black;
            font-family: 'Quicksand', 'Open Sans', 'Helvetica', 'Arial', san-serif;
        }
        a, h1, h2, h3, h4, h5, h6 {
            color: #0073aa;
        }
        .container {
            max-width: 800px;
            margin: auto;
            padding: 20px;
        }
        .has-small-font-size.is-link-to-top {
            position: absolute;
            bottom: 10px;
            right: 10px;
        }
        .entry-content {
            position:relative;
        }
        .entry-content img {
            max-width: 100%;
        }
    </style>
</head>
<body>
<div class='container'>
    
    <div class="page-metadata" data-published="" data-last-updated=""></div>
    
    <div aria-label="Breadcrumbs" class="wp-block-wporg-site-breadcrumbs has-small-font-size" role="navigation"><div class="wporg-site-breadcrumbs__wrapper"><span><a href="https://developer.wordpress.org">Home</a></span><span><a href="https://developer.wordpress.org/reference/">Reference</a></span><span><a href="https://developer.wordpress.org/reference/classes/">Classes</a></span><span class="is-current-page">WP_Object_Cache</span></div></div>  <!-- Full breadcrumbs HTML -->
    <h1>WP_Object_Cache</h1>
    <h1 class="wp-block-wporg-code-reference-title" style="margin-bottom:40px;"><span class="keyword">class</span> WP_Object_Cache {}</h1>
    
    <div class="content"><div class="entry-content wp-block-post-content is-layout-flow wp-container-core-post-content-is-layout-1 wp-block-post-content-is-layout-flow">
<section class="wp-block-wporg-code-reference-summary"><p>Core class that implements an object cache.</p>
</section>
<section class="wp-block-wporg-code-reference-description"><h2 class="is-toc-heading wp-block-heading has-heading-5-font-size" id="description" tabindex="-1"><a href="#description">Description</a></h2> <p>The WordPress Object Cache is used to save on trips to the database. The Object Cache stores all of the cache data to memory and makes the cache contents available by using a key, which is used to name and later retrieve the cache contents.</p>
<p>The Object Cache can be replaced by other caching mechanisms by placing files in the wp-content folder which is looked at in wp-settings. If that file exists, then this file will not be included.</p>
</section>
<section class="wporg-has-embedded-code wp-block-wporg-code-reference-explanation"><h2 class="is-toc-heading wp-block-heading has-heading-5-font-size" id="more-information" tabindex="-1"><a href="#more-information">More Information</a></h2>
<h2 class="is-toc-heading wp-block-heading" id="role-of-the-wordpress-object-cache" tabindex="-1"><a href="#role-of-the-wordpress-object-cache">Role of the WordPress Object Cache</a></h2>
<p><tt><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/" rel="class">WP_Object_Cache</a></tt> is WordPress’ class for caching data which may be computationally expensive to regenerate, such as the result of complex database queries. The object cache is defined in <code><a class="external text" href="https://core.trac.wordpress.org/browser/tags/5.5.1/src/wp-includes/cache.php#L0" rel="nofollow">wp-includes/cache.php</a></code>.</p>
<p>Do not use the class directly in your code when writing plugins, but use the <code>wp_cache_*</code> functions listed below.</p>
<p>By default, the object cache is non-persistent. This means that data stored in the cache resides in memory only and only for the duration of the request. Cached data will not be stored persistently across page loads unless you install a <a href="https://developer.notmatt.press/reference/classes/wp_object_cache/#persistent-caching">persistent caching</a> plugin.</p>
<p>Use the <a href="https://developer.notmatt.press/apis/handbook/transients/" title="Transients API">Transients API</a> instead of these functions if you need to guarantee that your data will be cached. If persistent caching is configured, then the transients functions will use the <tt>wp_cache_*</tt> functions described in this document. However if persistent caching has not been enabled, then the data will instead be cached to the options table.</p>
<p>Additionally, some object cache groups are designated as “non-persistent” and won’t be cached in persistent storage. This is useful when adding items to the cache that should only be available for the duration of a script session, and not between script invocations (or HTTP requests).</p>
<h2 class="is-toc-heading wp-block-heading" id="wp_cache_-functions" tabindex="-1"><a href="#wp_cache_-functions">wp_cache_* functions</a></h2>
<p>The most commonly used functions to interact with object cache are:</p>
<ul class="wp-block-list">
<li><a href="https://developer.notmatt.press/reference/functions/wp_cache_get/">wp_cache_get()</a></li>
<li><a href="https://developer.notmatt.press/reference/functions/wp_cache_set/">wp_cache_set()</a></li>
<li><a href="https://developer.notmatt.press/reference/functions/wp_cache_delete/">wp_cache_delete()</a></li>
<li><a href="https://developer.notmatt.press/reference/functions/wp_cache_flush/">wp_cache_flush()</a></li>
<li><a href="https://developer.notmatt.press/reference/functions/wp_cache_add/" rel="nofollow">wp_cache_add()</a></li>
<li><a href="https://developer.notmatt.press/reference/functions/wp_cache_replace/">wp_cache_replace()</a></li>
<li><a href="https://developer.notmatt.press/reference/functions/wp_cache_add_global_groups/">wp_cache_add_global_groups()</a></li>
<li><a href="https://developer.notmatt.press/reference/functions/wp_cache_add_non_persistent_groups/">wp_cache_add_non_persistent_groups()</a></li>
</ul>
<p>In recent version WordPress introduced object cache functions that can help using the cache more efficiently.</p>
<ul class="wp-block-list">
<li><a href="https://developer.notmatt.press/reference/functions/wp_cache_get_multiple/">wp_cache_get_multiple()</a></li>
<li><a href="https://developer.notmatt.press/reference/functions/wp_cache_set_multiple/">wp_cache_set_multiple()</a></li>
<li><a href="https://developer.notmatt.press/reference/functions/wp_cache_delete_multiple/">wp_cache_delete_multiple()</a></li>
<li><a href="https://developer.notmatt.press/reference/functions/wp_cache_add_multiple/">wp_cache_add_multiple()</a></li>
<li><a href="https://developer.notmatt.press/reference/functions/wp_cache_flush_group/">wp_cache_flush_group()</a></li>
<li><a href="https://developer.notmatt.press/reference/functions/wp_cache_flush_runtime/">wp_cache_flush_runtime()</a></li>
</ul>
<p>Testing whether newer functions are available cannot be done using <code>function_exists()</code>, but must be checked using <code>wp_cache_supports()</code> because WordPress will polyfill them. This means if an <a href="https://developer.notmatt.press/reference/classes/wp_object_cache/#persistent-cache-plugins">object caching plugin</a> does not support flushing cache groups, calling <code>wp_cache_flush_group()</code> blindly may cause the entire cache to be flushed.</p>
<pre class="wp-block-code"><code class="">if ( wp_cache_supports( 'flush_group' ) ) {
    wp_cache_flush_group( 'posts' )
} else {
    wp_cache_flush_cache();
}</code></pre>
<h2 class="is-toc-heading wp-block-heading" id="persistent-caching" tabindex="-1"><a href="#persistent-caching">Persistent Caching</a></h2>
<p>Prior to <a href="https://wordpress.org/support/wordpress-version/version-2-5/" title="Version 2.5">WordPress 2.5</a>, data stored using the wp_cache functions was stored persistently if you added <tt>define('WP_CACHE', true)</tt> to your <tt>wp-config.php</tt> file.</p>
<p>This is no longer the case, <b>and adding the define will have no effect</b> unless you install a persistent cache plugin (see examples below).</p>
<h2 class="is-toc-heading wp-block-heading" id="persistent-cache-plugins" tabindex="-1"><a href="#persistent-cache-plugins">Persistent Cache Plugins</a></h2>
<ul class="wp-block-list">
<li><a class="external text" href="https://wordpress.org/plugins/redis-cache/" rel="nofollow">Redis Object Cache</a> provides a persistent backend for the WordPress object cache. A <a class="external text" href="http://redis.io/" rel="nofollow">Redis</a> server is required.</li>
<li><a href="https://wordpress.org/plugins/memcached/" rel="nofollow">Memcached Object Cache</a> &amp; <a href="https://wordpress.org/plugins/memcached-redux/">Memcached Redux Object Cache</a> provides a persistent backend for the WordPress object cache. A <a href="https://memcached.org">memcached</a> server and the <a href="https://pecl.php.net/package/memcache">memcache extension</a> (or <a href="https://pecl.php.net/package/memcached">Memcache<strong>d</strong> extension</a> for Redux) for PHP are required.</li>
<li><a href="https://wordpress.org/plugins/docket-cache/">Docket Cache</a> uses php’s built-in opcode cache mechanism to provide a persistent object cache.</li>
<li><a class="external text" href="https://wordpress.org/plugins/sqlite-object-cache/">SQLite Object Cache</a> provides a persistent backend using the SQLite database engine. The <a href="https://www.php.net/sqlite3">SQLite3 extension</a> for PHP is required.</li>
</ul>
<p>Some caching plugins like <a class="external text" href="https://wordpress.org/extend/plugins/w3-total-cache/" rel="nofollow">W3 Total Cache</a> and <a class="external text" href="https://wordpress.org/plugins/litespeed-cache/" rel="nofollow">LiteSpeed Cache</a> provide object caches as well, but are not the easiest way to get object caching in WordPress, because they additionally offer browser, page, asset and CDN caching.</p>
<h2 class="is-toc-heading wp-block-heading" id="related" tabindex="-1"><a href="#related">Related</a></h2>
<p>The <a href="https://developer.notmatt.press/apis/handbook/transients/" title="Transients API">Transients_API</a> provides persistent but temporary data caching by giving it a custom name and a timeframe after which it will be expired and regenerated.</p>
<p><i>Note: Transients only get deleted when a request is made. So, until someone visits your page and calls up the Transient, it will stay in the DB. In short: It’s not a real persistent cache and not equal to stuff running on cron jobs.</i></p>
<h2 class="is-toc-heading wp-block-heading" id="resources" tabindex="-1"><a href="#resources">Resources</a></h2>
<ul class="wp-block-list">
<li>The <a class="external text" href="https://wordpress.org/plugins/debug-bar/" rel="nofollow">Debug Bar</a> and <a href="https://wordpress.org/plugins/query-monitor/">Query Monitor</a> plugins help you analyze the object cache.</li>
<li>Scott Taylor’s article <a class="external text" href="http://scotty-t.com/2012/01/20/wordpress-memcached/" rel="nofollow">WordPress + Memcached</a> explains various cache plugins and concepts.</li>
</ul>
</section>
<section class="wp-block-wporg-code-reference-methods"><h2 class="is-toc-heading wp-block-heading has-heading-5-font-size" id="methods" tabindex="-1"><a href="#methods">Methods</a></h2> <section class="wp-block-wporg-code-table" id="uses" style="margin-top:var(--wp--preset--spacing--20);"><figure class="wp-block-table"><table><thead><tr><th scope="col">Name</th><th scope="col">Description</th></tr></thead><tbody><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/__construct/">WP_Object_Cache::__construct</a></td><td>Sets up object properties.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/__get/">WP_Object_Cache::__get</a></td><td>Makes private properties readable for backward compatibility.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/__isset/">WP_Object_Cache::__isset</a></td><td>Makes private properties checkable for backward compatibility.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/__set/">WP_Object_Cache::__set</a></td><td>Makes private properties settable for backward compatibility.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/__unset/">WP_Object_Cache::__unset</a></td><td>Makes private properties un-settable for backward compatibility.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/_exists/">WP_Object_Cache::_exists</a></td><td>Serves as a utility function to determine whether a key exists in the cache.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/add/">WP_Object_Cache::add</a></td><td>Adds data to the cache if it doesn’t already exist.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/add_global_groups/">WP_Object_Cache::add_global_groups</a></td><td>Sets the list of global cache groups.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/add_multiple/">WP_Object_Cache::add_multiple</a></td><td>Adds multiple values to the cache in one call.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/decr/">WP_Object_Cache::decr</a></td><td>Decrements numeric cache item’s value.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/delete/">WP_Object_Cache::delete</a></td><td>Removes the contents of the cache key in the group.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/delete_multiple/">WP_Object_Cache::delete_multiple</a></td><td>Deletes multiple values from the cache in one call.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/flush/">WP_Object_Cache::flush</a></td><td>Clears the object cache of all data.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/flush_group/">WP_Object_Cache::flush_group</a></td><td>Removes all cache items in a group.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/get/">WP_Object_Cache::get</a></td><td>Retrieves the cache contents, if it exists.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/get_multiple/">WP_Object_Cache::get_multiple</a></td><td>Retrieves multiple values from the cache in one call.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/incr/">WP_Object_Cache::incr</a></td><td>Increments numeric cache item’s value.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/is_valid_key/">WP_Object_Cache::is_valid_key</a></td><td>Serves as a utility function to determine whether a key is valid.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/replace/">WP_Object_Cache::replace</a></td><td>Replaces the contents in the cache, if contents already exist.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/reset/">WP_Object_Cache::reset</a></td><td>Resets cache keys. — <span class="deprecated-method">deprecated</span></td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/set/">WP_Object_Cache::set</a></td><td>Sets the data contents into the cache.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/set_multiple/">WP_Object_Cache::set_multiple</a></td><td>Sets multiple values to the cache in one call.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/stats/">WP_Object_Cache::stats</a></td><td>Echoes the stats of the caching.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_object_cache/switch_to_blog/">WP_Object_Cache::switch_to_blog</a></td><td>Switches the internal blog ID.</td></tr></tbody></table></figure></section> </section>
<section class="wp-block-wporg-code-reference-source"><h2 class="is-toc-heading wp-block-heading has-heading-5-font-size" id="source" tabindex="-1"><a href="#source">Source</a></h2> <pre aria-label="Function source code" class="wp-block-code" data-start="25"><code class="language-php line-numbers" id="wporg-source-code" lang="php">class WP_Object_Cache {

	/**
	 * Holds the cached objects.
	 *
	 * @since 2.0.0
	 * @var array
	 */
	private $cache = array();

	/**
	 * The amount of times the cache data was already stored in the cache.
	 *
	 * @since 2.5.0
	 * @var int
	 */
	public $cache_hits = 0;

	/**
	 * Amount of times the cache did not have the request in cache.
	 *
	 * @since 2.0.0
	 * @var int
	 */
	public $cache_misses = 0;

	/**
	 * List of global cache groups.
	 *
	 * @since 3.0.0
	 * @var string[]
	 */
	protected $global_groups = array();

	/**
	 * The blog prefix to prepend to keys in non-global groups.
	 *
	 * @since 3.5.0
	 * @var string
	 */
	private $blog_prefix;

	/**
	 * Holds the value of is_multisite().
	 *
	 * @since 3.5.0
	 * @var bool
	 */
	private $multisite;

	/**
	 * Sets up object properties.
	 *
	 * @since 2.0.8
	 */
	public function __construct() {
		$this-&gt;multisite   = is_multisite();
		$this-&gt;blog_prefix = $this-&gt;multisite ? get_current_blog_id() . ':' : '';
	}

	/**
	 * Makes private properties readable for backward compatibility.
	 *
	 * @since 4.0.0
	 *
	 * @param string $name Property to get.
	 * @return mixed Property.
	 */
	public function __get( $name ) {
		return $this-&gt;$name;
	}

	/**
	 * Makes private properties settable for backward compatibility.
	 *
	 * @since 4.0.0
	 *
	 * @param string $name  Property to set.
	 * @param mixed  $value Property value.
	 */
	public function __set( $name, $value ) {
		$this-&gt;$name = $value;
	}

	/**
	 * Makes private properties checkable for backward compatibility.
	 *
	 * @since 4.0.0
	 *
	 * @param string $name Property to check if set.
	 * @return bool Whether the property is set.
	 */
	public function __isset( $name ) {
		return isset( $this-&gt;$name );
	}

	/**
	 * Makes private properties un-settable for backward compatibility.
	 *
	 * @since 4.0.0
	 *
	 * @param string $name Property to unset.
	 */
	public function __unset( $name ) {
		unset( $this-&gt;$name );
	}

	/**
	 * Serves as a utility function to determine whether a key is valid.
	 *
	 * @since 6.1.0
	 *
	 * @param int|string $key Cache key to check for validity.
	 * @return bool Whether the key is valid.
	 */
	protected function is_valid_key( $key ) {
		if ( is_int( $key ) ) {
			return true;
		}

		if ( is_string( $key ) &amp;&amp; trim( $key ) !== '' ) {
			return true;
		}

		$type = gettype( $key );

		if ( ! function_exists( '__' ) ) {
			wp_load_translations_early();
		}

		$message = is_string( $key )
			? __( 'Cache key must not be an empty string.' )
			/* translators: %s: The type of the given cache key. */
			: sprintf( __( 'Cache key must be an integer or a non-empty string, %s given.' ), $type );

		_doing_it_wrong(
			sprintf( '%s::%s', __CLASS__, debug_backtrace( DEBUG_BACKTRACE_IGNORE_ARGS, 2 )[1]['function'] ),
			$message,
			'6.1.0'
		);

		return false;
	}

	/**
	 * Serves as a utility function to determine whether a key exists in the cache.
	 *
	 * @since 3.4.0
	 *
	 * @param int|string $key   Cache key to check for existence.
	 * @param string     $group Cache group for the key existence check.
	 * @return bool Whether the key exists in the cache for the given group.
	 */
	protected function _exists( $key, $group ) {
		return isset( $this-&gt;cache[ $group ] ) &amp;&amp; ( isset( $this-&gt;cache[ $group ][ $key ] ) || array_key_exists( $key, $this-&gt;cache[ $group ] ) );
	}

	/**
	 * Adds data to the cache if it doesn't already exist.
	 *
	 * @since 2.0.0
	 *
	 * @uses WP_Object_Cache::_exists() Checks to see if the cache already has data.
	 * @uses WP_Object_Cache::set()     Sets the data after the checking the cache
	 *                                  contents existence.
	 *
	 * @param int|string $key    What to call the contents in the cache.
	 * @param mixed      $data   The contents to store in the cache.
	 * @param string     $group  Optional. Where to group the cache contents. Default 'default'.
	 * @param int        $expire Optional. When to expire the cache contents, in seconds.
	 *                           Default 0 (no expiration).
	 * @return bool True on success, false if cache key and group already exist.
	 */
	public function add( $key, $data, $group = 'default', $expire = 0 ) {
		if ( wp_suspend_cache_addition() ) {
			return false;
		}

		if ( ! $this-&gt;is_valid_key( $key ) ) {
			return false;
		}

		if ( empty( $group ) ) {
			$group = 'default';
		}

		$id = $key;
		if ( $this-&gt;multisite &amp;&amp; ! isset( $this-&gt;global_groups[ $group ] ) ) {
			$id = $this-&gt;blog_prefix . $key;
		}

		if ( $this-&gt;_exists( $id, $group ) ) {
			return false;
		}

		return $this-&gt;set( $key, $data, $group, (int) $expire );
	}

	/**
	 * Adds multiple values to the cache in one call.
	 *
	 * @since 6.0.0
	 *
	 * @param array  $data   Array of keys and values to be added.
	 * @param string $group  Optional. Where the cache contents are grouped. Default empty.
	 * @param int    $expire Optional. When to expire the cache contents, in seconds.
	 *                       Default 0 (no expiration).
	 * @return bool[] Array of return values, grouped by key. Each value is either
	 *                true on success, or false if cache key and group already exist.
	 */
	public function add_multiple( array $data, $group = '', $expire = 0 ) {
		$values = array();

		foreach ( $data as $key =&gt; $value ) {
			$values[ $key ] = $this-&gt;add( $key, $value, $group, $expire );
		}

		return $values;
	}

	/**
	 * Replaces the contents in the cache, if contents already exist.
	 *
	 * @since 2.0.0
	 *
	 * @see WP_Object_Cache::set()
	 *
	 * @param int|string $key    What to call the contents in the cache.
	 * @param mixed      $data   The contents to store in the cache.
	 * @param string     $group  Optional. Where to group the cache contents. Default 'default'.
	 * @param int        $expire Optional. When to expire the cache contents, in seconds.
	 *                           Default 0 (no expiration).
	 * @return bool True if contents were replaced, false if original value does not exist.
	 */
	public function replace( $key, $data, $group = 'default', $expire = 0 ) {
		if ( ! $this-&gt;is_valid_key( $key ) ) {
			return false;
		}

		if ( empty( $group ) ) {
			$group = 'default';
		}

		$id = $key;
		if ( $this-&gt;multisite &amp;&amp; ! isset( $this-&gt;global_groups[ $group ] ) ) {
			$id = $this-&gt;blog_prefix . $key;
		}

		if ( ! $this-&gt;_exists( $id, $group ) ) {
			return false;
		}

		return $this-&gt;set( $key, $data, $group, (int) $expire );
	}

	/**
	 * Sets the data contents into the cache.
	 *
	 * The cache contents are grouped by the $group parameter followed by the
	 * $key. This allows for duplicate IDs in unique groups. Therefore, naming of
	 * the group should be used with care and should follow normal function
	 * naming guidelines outside of core WordPress usage.
	 *
	 * The $expire parameter is not used, because the cache will automatically
	 * expire for each time a page is accessed and PHP finishes. The method is
	 * more for cache plugins which use files.
	 *
	 * @since 2.0.0
	 * @since 6.1.0 Returns false if cache key is invalid.
	 *
	 * @param int|string $key    What to call the contents in the cache.
	 * @param mixed      $data   The contents to store in the cache.
	 * @param string     $group  Optional. Where to group the cache contents. Default 'default'.
	 * @param int        $expire Optional. Not used.
	 * @return bool True if contents were set, false if key is invalid.
	 */
	public function set( $key, $data, $group = 'default', $expire = 0 ) {
		if ( ! $this-&gt;is_valid_key( $key ) ) {
			return false;
		}

		if ( empty( $group ) ) {
			$group = 'default';
		}

		if ( $this-&gt;multisite &amp;&amp; ! isset( $this-&gt;global_groups[ $group ] ) ) {
			$key = $this-&gt;blog_prefix . $key;
		}

		if ( is_object( $data ) ) {
			$data = clone $data;
		}

		$this-&gt;cache[ $group ][ $key ] = $data;
		return true;
	}

	/**
	 * Sets multiple values to the cache in one call.
	 *
	 * @since 6.0.0
	 *
	 * @param array  $data   Array of key and value to be set.
	 * @param string $group  Optional. Where the cache contents are grouped. Default empty.
	 * @param int    $expire Optional. When to expire the cache contents, in seconds.
	 *                       Default 0 (no expiration).
	 * @return bool[] Array of return values, grouped by key. Each value is always true.
	 */
	public function set_multiple( array $data, $group = '', $expire = 0 ) {
		$values = array();

		foreach ( $data as $key =&gt; $value ) {
			$values[ $key ] = $this-&gt;set( $key, $value, $group, $expire );
		}

		return $values;
	}

	/**
	 * Retrieves the cache contents, if it exists.
	 *
	 * The contents will be first attempted to be retrieved by searching by the
	 * key in the cache group. If the cache is hit (success) then the contents
	 * are returned.
	 *
	 * On failure, the number of cache misses will be incremented.
	 *
	 * @since 2.0.0
	 *
	 * @param int|string $key   The key under which the cache contents are stored.
	 * @param string     $group Optional. Where the cache contents are grouped. Default 'default'.
	 * @param bool       $force Optional. Unused. Whether to force an update of the local cache
	 *                          from the persistent cache. Default false.
	 * @param bool       $found Optional. Whether the key was found in the cache (passed by reference).
	 *                          Disambiguates a return of false, a storable value. Default null.
	 * @return mixed|false The cache contents on success, false on failure to retrieve contents.
	 */
	public function get( $key, $group = 'default', $force = false, &amp;$found = null ) {
		if ( ! $this-&gt;is_valid_key( $key ) ) {
			return false;
		}

		if ( empty( $group ) ) {
			$group = 'default';
		}

		if ( $this-&gt;multisite &amp;&amp; ! isset( $this-&gt;global_groups[ $group ] ) ) {
			$key = $this-&gt;blog_prefix . $key;
		}

		if ( $this-&gt;_exists( $key, $group ) ) {
			$found             = true;
			$this-&gt;cache_hits += 1;
			if ( is_object( $this-&gt;cache[ $group ][ $key ] ) ) {
				return clone $this-&gt;cache[ $group ][ $key ];
			} else {
				return $this-&gt;cache[ $group ][ $key ];
			}
		}

		$found               = false;
		$this-&gt;cache_misses += 1;
		return false;
	}

	/**
	 * Retrieves multiple values from the cache in one call.
	 *
	 * @since 5.5.0
	 *
	 * @param array  $keys  Array of keys under which the cache contents are stored.
	 * @param string $group Optional. Where the cache contents are grouped. Default 'default'.
	 * @param bool   $force Optional. Whether to force an update of the local cache
	 *                      from the persistent cache. Default false.
	 * @return array Array of return values, grouped by key. Each value is either
	 *               the cache contents on success, or false on failure.
	 */
	public function get_multiple( $keys, $group = 'default', $force = false ) {
		$values = array();

		foreach ( $keys as $key ) {
			$values[ $key ] = $this-&gt;get( $key, $group, $force );
		}

		return $values;
	}

	/**
	 * Removes the contents of the cache key in the group.
	 *
	 * If the cache key does not exist in the group, then nothing will happen.
	 *
	 * @since 2.0.0
	 *
	 * @param int|string $key        What the contents in the cache are called.
	 * @param string     $group      Optional. Where the cache contents are grouped. Default 'default'.
	 * @param bool       $deprecated Optional. Unused. Default false.
	 * @return bool True on success, false if the contents were not deleted.
	 */
	public function delete( $key, $group = 'default', $deprecated = false ) {
		if ( ! $this-&gt;is_valid_key( $key ) ) {
			return false;
		}

		if ( empty( $group ) ) {
			$group = 'default';
		}

		if ( $this-&gt;multisite &amp;&amp; ! isset( $this-&gt;global_groups[ $group ] ) ) {
			$key = $this-&gt;blog_prefix . $key;
		}

		if ( ! $this-&gt;_exists( $key, $group ) ) {
			return false;
		}

		unset( $this-&gt;cache[ $group ][ $key ] );
		return true;
	}

	/**
	 * Deletes multiple values from the cache in one call.
	 *
	 * @since 6.0.0
	 *
	 * @param array  $keys  Array of keys to be deleted.
	 * @param string $group Optional. Where the cache contents are grouped. Default empty.
	 * @return bool[] Array of return values, grouped by key. Each value is either
	 *                true on success, or false if the contents were not deleted.
	 */
	public function delete_multiple( array $keys, $group = '' ) {
		$values = array();

		foreach ( $keys as $key ) {
			$values[ $key ] = $this-&gt;delete( $key, $group );
		}

		return $values;
	}

	/**
	 * Increments numeric cache item's value.
	 *
	 * @since 3.3.0
	 *
	 * @param int|string $key    The cache key to increment.
	 * @param int        $offset Optional. The amount by which to increment the item's value.
	 *                           Default 1.
	 * @param string     $group  Optional. The group the key is in. Default 'default'.
	 * @return int|false The item's new value on success, false on failure.
	 */
	public function incr( $key, $offset = 1, $group = 'default' ) {
		if ( ! $this-&gt;is_valid_key( $key ) ) {
			return false;
		}

		if ( empty( $group ) ) {
			$group = 'default';
		}

		if ( $this-&gt;multisite &amp;&amp; ! isset( $this-&gt;global_groups[ $group ] ) ) {
			$key = $this-&gt;blog_prefix . $key;
		}

		if ( ! $this-&gt;_exists( $key, $group ) ) {
			return false;
		}

		if ( ! is_numeric( $this-&gt;cache[ $group ][ $key ] ) ) {
			$this-&gt;cache[ $group ][ $key ] = 0;
		}

		$offset = (int) $offset;

		$this-&gt;cache[ $group ][ $key ] += $offset;

		if ( $this-&gt;cache[ $group ][ $key ] &lt; 0 ) {
			$this-&gt;cache[ $group ][ $key ] = 0;
		}

		return $this-&gt;cache[ $group ][ $key ];
	}

	/**
	 * Decrements numeric cache item's value.
	 *
	 * @since 3.3.0
	 *
	 * @param int|string $key    The cache key to decrement.
	 * @param int        $offset Optional. The amount by which to decrement the item's value.
	 *                           Default 1.
	 * @param string     $group  Optional. The group the key is in. Default 'default'.
	 * @return int|false The item's new value on success, false on failure.
	 */
	public function decr( $key, $offset = 1, $group = 'default' ) {
		if ( ! $this-&gt;is_valid_key( $key ) ) {
			return false;
		}

		if ( empty( $group ) ) {
			$group = 'default';
		}

		if ( $this-&gt;multisite &amp;&amp; ! isset( $this-&gt;global_groups[ $group ] ) ) {
			$key = $this-&gt;blog_prefix . $key;
		}

		if ( ! $this-&gt;_exists( $key, $group ) ) {
			return false;
		}

		if ( ! is_numeric( $this-&gt;cache[ $group ][ $key ] ) ) {
			$this-&gt;cache[ $group ][ $key ] = 0;
		}

		$offset = (int) $offset;

		$this-&gt;cache[ $group ][ $key ] -= $offset;

		if ( $this-&gt;cache[ $group ][ $key ] &lt; 0 ) {
			$this-&gt;cache[ $group ][ $key ] = 0;
		}

		return $this-&gt;cache[ $group ][ $key ];
	}

	/**
	 * Clears the object cache of all data.
	 *
	 * @since 2.0.0
	 *
	 * @return true Always returns true.
	 */
	public function flush() {
		$this-&gt;cache = array();

		return true;
	}

	/**
	 * Removes all cache items in a group.
	 *
	 * @since 6.1.0
	 *
	 * @param string $group Name of group to remove from cache.
	 * @return true Always returns true.
	 */
	public function flush_group( $group ) {
		unset( $this-&gt;cache[ $group ] );

		return true;
	}

	/**
	 * Sets the list of global cache groups.
	 *
	 * @since 3.0.0
	 *
	 * @param string|string[] $groups List of groups that are global.
	 */
	public function add_global_groups( $groups ) {
		$groups = (array) $groups;

		$groups              = array_fill_keys( $groups, true );
		$this-&gt;global_groups = array_merge( $this-&gt;global_groups, $groups );
	}

	/**
	 * Switches the internal blog ID.
	 *
	 * This changes the blog ID used to create keys in blog specific groups.
	 *
	 * @since 3.5.0
	 *
	 * @param int $blog_id Blog ID.
	 */
	public function switch_to_blog( $blog_id ) {
		$blog_id           = (int) $blog_id;
		$this-&gt;blog_prefix = $this-&gt;multisite ? $blog_id . ':' : '';
	}

	/**
	 * Resets cache keys.
	 *
	 * @since 3.0.0
	 *
	 * @deprecated 3.5.0 Use WP_Object_Cache::switch_to_blog()
	 * @see switch_to_blog()
	 */
	public function reset() {
		_deprecated_function( __FUNCTION__, '3.5.0', 'WP_Object_Cache::switch_to_blog()' );

		// Clear out non-global caches since the blog ID has changed.
		foreach ( array_keys( $this-&gt;cache ) as $group ) {
			if ( ! isset( $this-&gt;global_groups[ $group ] ) ) {
				unset( $this-&gt;cache[ $group ] );
			}
		}
	}

	/**
	 * Echoes the stats of the caching.
	 *
	 * Gives the cache hits, and cache misses. Also prints every cached group,
	 * key and the data.
	 *
	 * @since 2.0.0
	 */
	public function stats() {
		echo '&lt;p&gt;';
		echo "&lt;strong&gt;Cache Hits:&lt;/strong&gt; {$this-&gt;cache_hits}&lt;br /&gt;";
		echo "&lt;strong&gt;Cache Misses:&lt;/strong&gt; {$this-&gt;cache_misses}&lt;br /&gt;";
		echo '&lt;/p&gt;';
		echo '&lt;ul&gt;';
		foreach ( $this-&gt;cache as $group =&gt; $cache ) {
			echo '&lt;li&gt;&lt;strong&gt;Group:&lt;/strong&gt; ' . esc_html( $group ) . ' - ( ' . number_format( strlen( serialize( $cache ) ) / KB_IN_BYTES, 2 ) . 'k )&lt;/li&gt;';
		}
		echo '&lt;/ul&gt;';
	}
}
</code></pre><p class="wporg-dot-link-list"><a href="https://developer.notmatt.press/reference/files/wp-includes/class-wp-object-cache.php/">View all references</a> <a href="https://core.trac.wordpress.org/browser/tags/6.7/src/wp-includes/class-wp-object-cache.php#L25">View on Trac</a> <a href="https://github.com/WordPress/wordpress-develop/blob/6.7/src/wp-includes/class-wp-object-cache.php#L25-L644">View on GitHub</a></p></section>
<section class="wp-block-wporg-code-reference-changelog"><h2 class="is-toc-heading wp-block-heading has-heading-5-font-size" id="changelog" tabindex="-1"><a href="#changelog">Changelog</a></h2> <section class="wp-block-wporg-code-table" style="margin-top:var(--wp--preset--spacing--20);"><figure class="wp-block-table"><table><thead><tr><th scope="col">Version</th><th scope="col">Description</th></tr></thead><tbody><tr class=""><td><a href="https://developer.notmatt.press/reference/since/2.0.0/">2.0.0</a></td><td>Introduced.</td></tr></tbody></table></figure></section> </section>
<section class="wp-block-wporg-code-reference-comments" data-nosnippet="true"><h2 class="is-toc-heading wp-block-heading" id="user-contributed-notes" tabindex="-1"><a href="#user-contributed-notes">User Contributed Notes</a></h2> <ol class="comment-list"> <li class="comment byuser comment-author-strackerphil-1 even thread-odd thread-alt depth-1" data-comment-id="5746" id="comment-5746">
<article class="comment-body" id="div-comment-5746">
<a class="screen-reader-text" href="#comment-content-5746">Skip to note 6 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-5746">
<p>It’s important to note that objects are not referenced, but <strong>a clone of the object is stored in the cache</strong>!</p>
<p>If you update an object, after it was added to the cache, <strong>the item in the cache will not change</strong>, unless you update the cache with the new object</p>
<pre class="wp-block-code"><code class="language-php line-numbers" lang="php">class SomeItem {
	private $value = 0;
	function add() { $this-&gt;value++; }
	function show() { echo "{$this-&gt;value}n"; }
}

$item = new SomeItem;
$item-&gt;show(); // Prints "0"
wp_cache_set( 'test-1', $item );

// Modify item after it was written to object cache.
// This call updates the local object, but not the item in the cache!
$item-&gt;add();
$item-&gt;show(); // Prints "1"

// Get the item from cache.
$item = wp_cache_get( 'test-1' );
$item-&gt;show(); // Prints "0" <span aria-hidden="true" class="wp-exclude-emoji"><span aria-hidden="true" class="wp-exclude-emoji">←</span></span> possibly an unexpected result.</code></pre>
<p>Reference: Here’s the <a href="https://core.trac.wordpress.org/browser/tags/5.9/src/wp-includes/class-wp-object-cache.php?marks=442-444#L413" rel="nofollow ugc">relevant part of the core function</a>.</p>
<p><strong>Solution:</strong><br/>
Since WordPress only clones objects (using the `clone` keyword), there are several ways to bypass the limitation, with minimal extra code, such as this here:</p>
<pre class="wp-block-code"><code class="language-php line-numbers" lang="php">class SomeItem {
	private $value = 0;
	function add() { $this-&gt;value++; }
	function show() { echo "{$this-&gt;value}n"; }
}

$item = new SomeItem;
$item-&gt;show(); // "0"

// Assign our instance to an array. Arrays are not cloned and references will stay intact:
$cacheData = [ 'ref' =&gt; $item ];

// Cache the wrapped instance:
wp_cache_set( 'test-1', $cacheData );

// Modify item after it was written to object cache.
$item-&gt;add();
$item-&gt;show(); // "1"

// Get the wrapped instance from cache.
$cacheData = wp_cache_get('test-1');
$item = $cacheData['ref']; // Retrieve the actual instance from our array

$item-&gt;show(); // Prints "1", as expected!</code></pre>
<p><strong>Helper functions:</strong></p>
<pre class="wp-block-code"><code class="language-php" lang="php">// Setter
function wp_cache_set_ref( $key, $data, $group = '', $expire = 0 ) {
    return wp_cache_set( $key, [ 'ref' =&gt; $data ], $group, $expire );
}</code></pre>
<pre class="wp-block-code"><code class="language-php line-numbers" lang="php">// Getter
function wp_cache_get_ref( $key, $group = '', $force = false, &amp;$found = null ) {
    $wrapper = wp_cache_get( $key, $group, $force, $found );
    if ( is_array( $wrapper ) &amp;&amp; array_key_exists( 'ref', $wrapper ) ) {
        return $wrapper['ref'];
    }
    return $wrapper;
}</code></pre>
<pre class="wp-block-code"><code class="language-php line-numbers" lang="php">// Usage
class SomeItem {
	private $value = 0;
	function add() { $this-&gt;value++; }
	function show() { echo "{$this-&gt;value}n"; }
}

$item = new SomeItem;
$item-&gt;show(); // "0"

wp_cache_set_ref( 'test-1', $item );

$item-&gt;add();
$item-&gt;show(); // "1"

$item = wp_cache_get_ref( 'test-1' );
$item-&gt;show(); // "1"</code></pre>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="1" id="feedback-5746">
<ul class="children">
<li class="comment byuser comment-author-lev0 odd alt depth-2" data-comment-id="6620" id="comment-6620">
<article class="comment-body" id="div-comment-6620">
<div class="wporg-has-embedded-code comment-content" id="comment-content-6620">
<div>I think this workaround needs a huge warning, and should generally be avoided. It gives the impression that cached objects can be made modifiable <em>after</em> being stored, whereas all this does is pass around a copied object reference for one request. Changes can be made to such an object but they will only apply to the in-memory copy, not the one written to persistent cache. This may be acceptable if you’re not using persistent cache but that typically defeats the purpose of caching. With persistent cache, subsequent requests will restore the object to the state it had at the time of last save, without any of the modifications made after that point.</div>
<div><a class="url" href="https://profiles.wordpress.org/lev0/" rel="external nofollow">Roy Orbitson</a> <a class="comment-date" href="https://developer.notmatt.press/reference/classes/wp_object_cache/#comment-6620"><time datetime="2023-08-14T05:37:19+00:00">1 year ago</time></a></div>
</div><!-- .comment-content -->
</article>
</li>
</ul>
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
<li class="comment byuser comment-author-xnau even thread-even depth-1" data-comment-id="5412" id="comment-5412">
<article class="comment-body" id="div-comment-5412">
<a class="screen-reader-text" href="#comment-content-5412">Skip to note 7 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-5412">
<p>It’s easy to miss this, but it’s important to remember that the actual expiration time for the cache depends on whether a persistent cache is set up on the user’s site or not.</p>
<p>If there is no persistent cache set up, the cache does not persist across page loads, so it doesn’t matter much what the expiration time is.</p>
<p>However, if is persistent cache is installed, and no expiration time is set, the cache can end up being “sticky” and more persistent than intended. This can lead to problems that may not show up in tests.</p>
<p>It’s probably a good practice to set an expiration time to avoid this.</p>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="0" id="feedback-5412">
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
<li class="comment byuser comment-author-priyankabehera155 odd alt thread-odd thread-alt depth-1" data-comment-id="1976" id="comment-1976">
<article class="comment-body" id="div-comment-1976">
<a class="screen-reader-text" href="#comment-content-1976">Skip to note 8 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-1976">
<p><strong>The object cache is used for caching the results of expensive SQL queries. So they’re not performed multiple times within a page load. In the below example, imagine the $query variable is an expensive SQL query.</strong></p>
<pre class="wp-block-code"><code class="language-php line-numbers" lang="php">$result = wp_cache_get( 'my_result' );
if ( false === $result ) {
	$result = $wpdb-&gt;get_results( $query );
	wp_cache_set( 'my_result', $result );
} 
// Do something with $result;</code></pre>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="0" id="feedback-1976">
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
<li class="comment byuser comment-author-olliejones even thread-even depth-1" data-comment-id="6285" id="comment-6285">
<article class="comment-body" id="div-comment-6285">
<a class="screen-reader-text" href="#comment-content-6285">Skip to note 9 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-6285">
<p>Many hosts do not provide redis or memcached servers, but do provide the <a href="https://www.php.net/manual/en/book.sqlite3.php" rel="nofollow ugc">SQLite3</a> extension to php. </p>
<p>Sites running on those hosts can use the <a href="https://wordpress.org/plugins/sqlite-object-cache/" rel="nofollow ugc">SQLite Object Cache</a> plugin to provide persistent object caching and get the performance benefits.</p>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="0" id="feedback-6285">
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
<li class="comment byuser comment-author-olliejones odd alt thread-odd thread-alt depth-1" data-comment-id="6437" id="comment-6437">
<article class="comment-body" id="div-comment-6437">
<a class="screen-reader-text" href="#comment-content-6437">Skip to note 10 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-6437">
<p>Notes to implementers of the *_multiple() functions: </p>
<ul>
<li>Most, if not all, the `$keys` are numeric.</li>
<li>They’re not always in order. </li>
<li>Sometimes the keys arrays passed to calls to `<a href="https://developer.notmatt.press/reference/functions/wp_cache_get_multiple/" rel="function">wp_cache_get_multiple()</a> ` contain duplicates.</li>
</ul>
<p>This is as of version 6.2.</p>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="0" id="feedback-6437">
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
</ol></section>
</div></div>
    </div>
<footer class="text-center mt-10 py-5">
    <p class="text-sm"><a href="https://notmatt.press">NotMattPress</a>.</p>
</footer>
</body>
</html>
