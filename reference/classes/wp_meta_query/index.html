
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Untitled Page</title>
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@3.3.5/dist/tailwind.min.css" rel="stylesheet">
    <style>
        body {
            background-color: white;
            color: black;
            font-family: 'Quicksand', 'Open Sans', 'Helvetica', 'Arial', san-serif;
        }
        a, h1, h2, h3, h4, h5, h6 {
            color: #0073aa;
        }
        .container {
            max-width: 800px;
            margin: auto;
            padding: 20px;
        }
        .has-small-font-size.is-link-to-top {
            position: absolute;
            bottom: 10px;
            right: 10px;
        }
        .entry-content {
            position:relative;
        }
        .entry-content img {
            max-width: 100%;
        }
    </style>
</head>
<body>
<div class='container'>
    
    <div class="page-metadata" data-published="" data-last-updated=""></div>
    
    <div aria-label="Breadcrumbs" class="wp-block-wporg-site-breadcrumbs has-small-font-size" role="navigation"><div class="wporg-site-breadcrumbs__wrapper"><span><a href="https://developer.wordpress.org">Home</a></span><span><a href="https://developer.wordpress.org/reference/">Reference</a></span><span><a href="https://developer.wordpress.org/reference/classes/">Classes</a></span><span class="is-current-page">WP_Meta_Query</span></div></div>  <!-- Full breadcrumbs HTML -->
    <h1>WP_Meta_Query</h1>
    <h1 class="wp-block-wporg-code-reference-title" style="margin-bottom:40px;"><span class="keyword">class</span> WP_Meta_Query {}</h1>
    
    <div class="content"><div class="entry-content wp-block-post-content is-layout-flow wp-container-core-post-content-is-layout-1 wp-block-post-content-is-layout-flow">
<section class="wp-block-wporg-code-reference-summary"><p>Core class used to implement meta queries for the Meta API.</p>
</section>
<section class="wp-block-wporg-code-reference-description"><h2 class="is-toc-heading wp-block-heading has-heading-5-font-size" id="description" tabindex="-1"><a href="#description">Description</a></h2> <p>Used for generating SQL clauses that filter a primary query according to metadata keys and values.</p>
<p><a href="https://developer.notmatt.press/reference/classes/wp_meta_query/" rel="class">WP_Meta_Query</a> is a helper that allows primary query classes, such as <a href="https://developer.notmatt.press/reference/classes/wp_query/" rel="class">WP_Query</a> and <a href="https://developer.notmatt.press/reference/classes/wp_user_query/" rel="class">WP_User_Query</a>,</p>
<p>to filter their results by object metadata, by generating <code>JOIN</code> and <code>WHERE</code> subclauses to be attached to the primary SQL query string.</p>
</section>
<section class="wporg-has-embedded-code wp-block-wporg-code-reference-explanation"><h2 class="is-toc-heading wp-block-heading has-heading-5-font-size" id="more-information" tabindex="-1"><a href="#more-information">More Information</a></h2>
<h2 class="is-toc-heading wp-block-heading" id="description-2" tabindex="-1"><a href="#description-2">Description</a></h2>
<p><a href="https://developer.notmatt.press/reference/classes/wp_meta_query/" rel="class">WP_Meta_Query</a> is a class defined in wp-includes/meta.php that generates the necessary SQL for meta-related queries. It was introduced in Version 3.2.0 and greatly improved the possibility to query posts by custom fields. In the WP core, it’s used in the <a href="https://developer.notmatt.press/reference/classes/wp_query/" title="Class Reference/WP Query">WP_Query</a> and <a href="https://developer.notmatt.press/reference/classes/wp_user_query/" title="Class Reference/WP User Query">WP_User_Query</a> classes, and since Version 3.5 in the <a href="https://developer.notmatt.press/reference/classes/wp_comment_query/" title="Class Reference/WP Comment Query">WP_Comment_Query</a> class. Unless you’re writing a custom SQL query, you should look in the *Custom Field Parameters* section for the corresponding class.</p>
<h2 class="is-toc-heading wp-block-heading" id="usage" tabindex="-1"><a href="#usage">Usage</a></h2>
<h3 class="is-toc-heading wp-block-heading" id="accepted-arguments" tabindex="-1"><a href="#accepted-arguments">Accepted Arguments</a></h3>
<p>The following arguments can be passed in a key=&gt;value paired array.</p>
<ul class="wp-block-list">
<li><b><tt>meta_key</tt></b> (<i>string</i>) – Custom field key. ( You must sanitize this yourself )</li>
<li><b><tt>meta_value</tt></b> (<i>string|array</i>) – Custom field value. ( You must sanitize this yourself )</li>
<li><b><tt>meta_type</tt></b> (<i>string</i>) – Custom field type (see <b><tt>type</tt></b> below for options).</li>
<li><b><tt>meta_compare</tt></b> (<i>string</i>) – Operator to test the <tt>'meta_value'</tt> (see <b><tt>compare</tt></b> below for possible values).</li>
<li><b><tt>meta_query</tt></b> (<i>array</i>) – Contains one or more arrays with the following keys:
<ul class="wp-block-list">
<li><b><tt>key</tt></b> (<i>string</i>) – Custom field key.</li>
<li><b><tt>value</tt></b> (<i>string</i>|<i>array</i>) – Custom field value. It can be an array only when <tt><b>compare</b></tt> is <tt>'IN'</tt>, <tt>'NOT IN'</tt>, <tt>'BETWEEN'</tt>, or <tt>'NOT BETWEEN'</tt>. You don’t have to specify a value when using the <tt>'EXISTS'</tt> or <tt>'NOT EXISTS'</tt> comparisons in WordPress 3.9 and up.<br/>
(<strong>Note:</strong> Due to <a class="external text" href="https://core.trac.wordpress.org/ticket/23268" rel="nofollow">bug #23268</a>, <tt>value</tt> was required for <tt>NOT EXISTS</tt> comparisons to work correctly prior to 3.9. You had to supply <i>some</i> string for the <tt>value</tt> parameter. An empty string or <tt>NULL</tt> will NOT work. However, any other string will do the trick and will NOT show up in your SQL when using <tt>NOT EXISTS</tt>. Need inspiration? How about <tt>'bug #23268'</tt>.)</li>
<li><b><tt>compare</tt></b> (<i>string</i>) – Operator to test. Possible values are ‘=’, ‘!=’, ‘&gt;’, ‘&gt;=’, ‘&lt;‘, ‘&lt;=’, ‘LIKE’, ‘NOT LIKE’, ‘IN’, ‘NOT IN’, ‘BETWEEN’, ‘NOT BETWEEN’, ‘EXISTS’ (only in WP &gt;= 3.5), and ‘NOT EXISTS’ (also only in WP &gt;= 3.5). Values ‘REGEXP’, ‘NOT REGEXP’ and ‘RLIKE’ were added in WordPress 3.7. Default value is ‘=’.</li>
<li><b><tt>type</tt></b> (<i>string</i>) – Custom field type. Possible values are ‘NUMERIC’, ‘BINARY’, ‘CHAR’, ‘DATE’, ‘DATETIME’, ‘DECIMAL’, ‘SIGNED’, ‘TIME’, ‘UNSIGNED’. Default value is ‘CHAR’.</li>
</ul>
</li>
</ul>
<p>The <tt>'type'</tt> <tt>DATE</tt> works with the <tt>'compare'</tt> value <tt>BETWEEN</tt> only if the date is stored at the format <tt>YYYY-MM-DD</tt> and tested with this format.</p>
<p><em>Note:</em> The <tt>'meta_key'</tt>, <tt>'meta_value'</tt>, <tt>'meta_type'</tt> and <tt>'meta_compare'</tt> arguments will only work if you use the second method described below.</p>
</section>
<section class="wp-block-wporg-code-reference-methods"><h2 class="is-toc-heading wp-block-heading has-heading-5-font-size" id="methods" tabindex="-1"><a href="#methods">Methods</a></h2> <section class="wp-block-wporg-code-table" id="uses" style="margin-top:var(--wp--preset--spacing--20);"><figure class="wp-block-table"><table><thead><tr><th scope="col">Name</th><th scope="col">Description</th></tr></thead><tbody><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_meta_query/__construct/">WP_Meta_Query::__construct</a></td><td>Constructor.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_meta_query/find_compatible_table_alias/">WP_Meta_Query::find_compatible_table_alias</a></td><td>Identifies an existing table alias that is compatible with the current query clause.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_meta_query/get_cast_for_type/">WP_Meta_Query::get_cast_for_type</a></td><td>Returns the appropriate alias for the given meta type if applicable.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_meta_query/get_clauses/">WP_Meta_Query::get_clauses</a></td><td>Gets a flattened list of sanitized meta clauses.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_meta_query/get_sql/">WP_Meta_Query::get_sql</a></td><td>Generates SQL clauses to be appended to a main query.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_meta_query/get_sql_clauses/">WP_Meta_Query::get_sql_clauses</a></td><td>Generates SQL clauses to be appended to a main query.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_meta_query/get_sql_for_clause/">WP_Meta_Query::get_sql_for_clause</a></td><td>Generates SQL JOIN and WHERE clauses for a first-order query clause.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_meta_query/get_sql_for_query/">WP_Meta_Query::get_sql_for_query</a></td><td>Generates SQL clauses for a single query array.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_meta_query/has_or_relation/">WP_Meta_Query::has_or_relation</a></td><td>Checks whether the current query has any OR relations.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_meta_query/is_first_order_clause/">WP_Meta_Query::is_first_order_clause</a></td><td>Determines whether a query clause is first-order.</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_meta_query/parse_query_vars/">WP_Meta_Query::parse_query_vars</a></td><td>Constructs a meta query based on ‘meta_*’ query vars</td></tr><tr class=""><td><a href="https://developer.notmatt.press/reference/classes/wp_meta_query/sanitize_query/">WP_Meta_Query::sanitize_query</a></td><td>Ensures the ‘meta_query’ argument passed to the class constructor is well-formed.</td></tr></tbody></table></figure></section> </section>
<section class="wp-block-wporg-code-reference-source"><h2 class="is-toc-heading wp-block-heading has-heading-5-font-size" id="source" tabindex="-1"><a href="#source">Source</a></h2> <pre aria-label="Function source code" class="wp-block-code" data-start="23"><code class="language-php line-numbers" id="wporg-source-code" lang="php">class WP_Meta_Query {
	/**
	 * Array of metadata queries.
	 *
	 * See WP_Meta_Query::__construct() for information on meta query arguments.
	 *
	 * @since 3.2.0
	 * @var array
	 */
	public $queries = array();

	/**
	 * The relation between the queries. Can be one of 'AND' or 'OR'.
	 *
	 * @since 3.2.0
	 * @var string
	 */
	public $relation;

	/**
	 * Database table to query for the metadata.
	 *
	 * @since 4.1.0
	 * @var string
	 */
	public $meta_table;

	/**
	 * Column in meta_table that represents the ID of the object the metadata belongs to.
	 *
	 * @since 4.1.0
	 * @var string
	 */
	public $meta_id_column;

	/**
	 * Database table that where the metadata's objects are stored (eg $wpdb-&gt;users).
	 *
	 * @since 4.1.0
	 * @var string
	 */
	public $primary_table;

	/**
	 * Column in primary_table that represents the ID of the object.
	 *
	 * @since 4.1.0
	 * @var string
	 */
	public $primary_id_column;

	/**
	 * A flat list of table aliases used in JOIN clauses.
	 *
	 * @since 4.1.0
	 * @var array
	 */
	protected $table_aliases = array();

	/**
	 * A flat list of clauses, keyed by clause 'name'.
	 *
	 * @since 4.2.0
	 * @var array
	 */
	protected $clauses = array();

	/**
	 * Whether the query contains any OR relations.
	 *
	 * @since 4.3.0
	 * @var bool
	 */
	protected $has_or_relation = false;

	/**
	 * Constructor.
	 *
	 * @since 3.2.0
	 * @since 4.2.0 Introduced support for naming query clauses by associative array keys.
	 * @since 5.1.0 Introduced `$compare_key` clause parameter, which enables LIKE key matches.
	 * @since 5.3.0 Increased the number of operators available to `$compare_key`. Introduced `$type_key`,
	 *              which enables the `$key` to be cast to a new data type for comparisons.
	 *
	 * @param array $meta_query {
	 *     Array of meta query clauses. When first-order clauses or sub-clauses use strings as
	 *     their array keys, they may be referenced in the 'orderby' parameter of the parent query.
	 *
	 *     @type string $relation Optional. The MySQL keyword used to join the clauses of the query.
	 *                            Accepts 'AND' or 'OR'. Default 'AND'.
	 *     @type array  ...$0 {
	 *         Optional. An array of first-order clause parameters, or another fully-formed meta query.
	 *
	 *         @type string|string[] $key         Meta key or keys to filter by.
	 *         @type string          $compare_key MySQL operator used for comparing the $key. Accepts:
	 *                                            - '='
	 *                                            - '!='
	 *                                            - 'LIKE'
	 *                                            - 'NOT LIKE'
	 *                                            - 'IN'
	 *                                            - 'NOT IN'
	 *                                            - 'REGEXP'
	 *                                            - 'NOT REGEXP'
	 *                                            - 'RLIKE'
	 *                                            - 'EXISTS' (alias of '=')
	 *                                            - 'NOT EXISTS' (alias of '!=')
	 *                                            Default is 'IN' when `$key` is an array, '=' otherwise.
	 *         @type string          $type_key    MySQL data type that the meta_key column will be CAST to for
	 *                                            comparisons. Accepts 'BINARY' for case-sensitive regular expression
	 *                                            comparisons. Default is ''.
	 *         @type string|string[] $value       Meta value or values to filter by.
	 *         @type string          $compare     MySQL operator used for comparing the $value. Accepts:
	 *                                            - '='
	 *                                            - '!='
	 *                                            - '&gt;'
	 *                                            - '&gt;='
	 *                                            - '&lt;'
	 *                                            - '&lt;='
	 *                                            - 'LIKE'
	 *                                            - 'NOT LIKE'
	 *                                            - 'IN'
	 *                                            - 'NOT IN'
	 *                                            - 'BETWEEN'
	 *                                            - 'NOT BETWEEN'
	 *                                            - 'REGEXP'
	 *                                            - 'NOT REGEXP'
	 *                                            - 'RLIKE'
	 *                                            - 'EXISTS'
	 *                                            - 'NOT EXISTS'
	 *                                            Default is 'IN' when `$value` is an array, '=' otherwise.
	 *         @type string          $type        MySQL data type that the meta_value column will be CAST to for
	 *                                            comparisons. Accepts:
	 *                                            - 'NUMERIC'
	 *                                            - 'BINARY'
	 *                                            - 'CHAR'
	 *                                            - 'DATE'
	 *                                            - 'DATETIME'
	 *                                            - 'DECIMAL'
	 *                                            - 'SIGNED'
	 *                                            - 'TIME'
	 *                                            - 'UNSIGNED'
	 *                                            Default is 'CHAR'.
	 *     }
	 * }
	 */
	public function __construct( $meta_query = false ) {
		if ( ! $meta_query ) {
			return;
		}

		if ( isset( $meta_query['relation'] ) &amp;&amp; 'OR' === strtoupper( $meta_query['relation'] ) ) {
			$this-&gt;relation = 'OR';
		} else {
			$this-&gt;relation = 'AND';
		}

		$this-&gt;queries = $this-&gt;sanitize_query( $meta_query );
	}

	/**
	 * Ensures the 'meta_query' argument passed to the class constructor is well-formed.
	 *
	 * Eliminates empty items and ensures that a 'relation' is set.
	 *
	 * @since 4.1.0
	 *
	 * @param array $queries Array of query clauses.
	 * @return array Sanitized array of query clauses.
	 */
	public function sanitize_query( $queries ) {
		$clean_queries = array();

		if ( ! is_array( $queries ) ) {
			return $clean_queries;
		}

		foreach ( $queries as $key =&gt; $query ) {
			if ( 'relation' === $key ) {
				$relation = $query;

			} elseif ( ! is_array( $query ) ) {
				continue;

				// First-order clause.
			} elseif ( $this-&gt;is_first_order_clause( $query ) ) {
				if ( isset( $query['value'] ) &amp;&amp; array() === $query['value'] ) {
					unset( $query['value'] );
				}

				$clean_queries[ $key ] = $query;

				// Otherwise, it's a nested query, so we recurse.
			} else {
				$cleaned_query = $this-&gt;sanitize_query( $query );

				if ( ! empty( $cleaned_query ) ) {
					$clean_queries[ $key ] = $cleaned_query;
				}
			}
		}

		if ( empty( $clean_queries ) ) {
			return $clean_queries;
		}

		// Sanitize the 'relation' key provided in the query.
		if ( isset( $relation ) &amp;&amp; 'OR' === strtoupper( $relation ) ) {
			$clean_queries['relation'] = 'OR';
			$this-&gt;has_or_relation     = true;

			/*
			* If there is only a single clause, call the relation 'OR'.
			* This value will not actually be used to join clauses, but it
			* simplifies the logic around combining key-only queries.
			*/
		} elseif ( 1 === count( $clean_queries ) ) {
			$clean_queries['relation'] = 'OR';

			// Default to AND.
		} else {
			$clean_queries['relation'] = 'AND';
		}

		return $clean_queries;
	}

	/**
	 * Determines whether a query clause is first-order.
	 *
	 * A first-order meta query clause is one that has either a 'key' or
	 * a 'value' array key.
	 *
	 * @since 4.1.0
	 *
	 * @param array $query Meta query arguments.
	 * @return bool Whether the query clause is a first-order clause.
	 */
	protected function is_first_order_clause( $query ) {
		return isset( $query['key'] ) || isset( $query['value'] );
	}

	/**
	 * Constructs a meta query based on 'meta_*' query vars
	 *
	 * @since 3.2.0
	 *
	 * @param array $qv The query variables.
	 */
	public function parse_query_vars( $qv ) {
		$meta_query = array();

		/*
		 * For orderby=meta_value to work correctly, simple query needs to be
		 * first (so that its table join is against an unaliased meta table) and
		 * needs to be its own clause (so it doesn't interfere with the logic of
		 * the rest of the meta_query).
		 */
		$primary_meta_query = array();
		foreach ( array( 'key', 'compare', 'type', 'compare_key', 'type_key' ) as $key ) {
			if ( ! empty( $qv[ "meta_$key" ] ) ) {
				$primary_meta_query[ $key ] = $qv[ "meta_$key" ];
			}
		}

		// WP_Query sets 'meta_value' = '' by default.
		if ( isset( $qv['meta_value'] ) &amp;&amp; '' !== $qv['meta_value'] &amp;&amp; ( ! is_array( $qv['meta_value'] ) || $qv['meta_value'] ) ) {
			$primary_meta_query['value'] = $qv['meta_value'];
		}

		$existing_meta_query = isset( $qv['meta_query'] ) &amp;&amp; is_array( $qv['meta_query'] ) ? $qv['meta_query'] : array();

		if ( ! empty( $primary_meta_query ) &amp;&amp; ! empty( $existing_meta_query ) ) {
			$meta_query = array(
				'relation' =&gt; 'AND',
				$primary_meta_query,
				$existing_meta_query,
			);
		} elseif ( ! empty( $primary_meta_query ) ) {
			$meta_query = array(
				$primary_meta_query,
			);
		} elseif ( ! empty( $existing_meta_query ) ) {
			$meta_query = $existing_meta_query;
		}

		$this-&gt;__construct( $meta_query );
	}

	/**
	 * Returns the appropriate alias for the given meta type if applicable.
	 *
	 * @since 3.7.0
	 *
	 * @param string $type MySQL type to cast meta_value.
	 * @return string MySQL type.
	 */
	public function get_cast_for_type( $type = '' ) {
		if ( empty( $type ) ) {
			return 'CHAR';
		}

		$meta_type = strtoupper( $type );

		if ( ! preg_match( '/^(?:BINARY|CHAR|DATE|DATETIME|SIGNED|UNSIGNED|TIME|NUMERIC(?:\(\d+(?:,\s?\d+)?\))?|DECIMAL(?:\(\d+(?:,\s?\d+)?\))?)$/', $meta_type ) ) {
			return 'CHAR';
		}

		if ( 'NUMERIC' === $meta_type ) {
			$meta_type = 'SIGNED';
		}

		return $meta_type;
	}

	/**
	 * Generates SQL clauses to be appended to a main query.
	 *
	 * @since 3.2.0
	 *
	 * @param string $type              Type of meta. Possible values include but are not limited
	 *                                  to 'post', 'comment', 'blog', 'term', and 'user'.
	 * @param string $primary_table     Database table where the object being filtered is stored (eg wp_users).
	 * @param string $primary_id_column ID column for the filtered object in $primary_table.
	 * @param object $context           Optional. The main query object that corresponds to the type, for
	 *                                  example a `WP_Query`, `WP_User_Query`, or `WP_Site_Query`.
	 *                                  Default null.
	 * @return string[]|false {
	 *     Array containing JOIN and WHERE SQL clauses to append to the main query,
	 *     or false if no table exists for the requested meta type.
	 *
	 *     @type string $join  SQL fragment to append to the main JOIN clause.
	 *     @type string $where SQL fragment to append to the main WHERE clause.
	 * }
	 */
	public function get_sql( $type, $primary_table, $primary_id_column, $context = null ) {
		$meta_table = _get_meta_table( $type );
		if ( ! $meta_table ) {
			return false;
		}

		$this-&gt;table_aliases = array();

		$this-&gt;meta_table     = $meta_table;
		$this-&gt;meta_id_column = sanitize_key( $type . '_id' );

		$this-&gt;primary_table     = $primary_table;
		$this-&gt;primary_id_column = $primary_id_column;

		$sql = $this-&gt;get_sql_clauses();

		/*
		 * If any JOINs are LEFT JOINs (as in the case of NOT EXISTS), then all JOINs should
		 * be LEFT. Otherwise posts with no metadata will be excluded from results.
		 */
		if ( str_contains( $sql['join'], 'LEFT JOIN' ) ) {
			$sql['join'] = str_replace( 'INNER JOIN', 'LEFT JOIN', $sql['join'] );
		}

		/**
		 * Filters the meta query's generated SQL.
		 *
		 * @since 3.1.0
		 *
		 * @param string[] $sql               Array containing the query's JOIN and WHERE clauses.
		 * @param array    $queries           Array of meta queries.
		 * @param string   $type              Type of meta. Possible values include but are not limited
		 *                                    to 'post', 'comment', 'blog', 'term', and 'user'.
		 * @param string   $primary_table     Primary table.
		 * @param string   $primary_id_column Primary column ID.
		 * @param object   $context           The main query object that corresponds to the type, for
		 *                                    example a `WP_Query`, `WP_User_Query`, or `WP_Site_Query`.
		 */
		return apply_filters_ref_array( 'get_meta_sql', array( $sql, $this-&gt;queries, $type, $primary_table, $primary_id_column, $context ) );
	}

	/**
	 * Generates SQL clauses to be appended to a main query.
	 *
	 * Called by the public WP_Meta_Query::get_sql(), this method is abstracted
	 * out to maintain parity with the other Query classes.
	 *
	 * @since 4.1.0
	 *
	 * @return string[] {
	 *     Array containing JOIN and WHERE SQL clauses to append to the main query.
	 *
	 *     @type string $join  SQL fragment to append to the main JOIN clause.
	 *     @type string $where SQL fragment to append to the main WHERE clause.
	 * }
	 */
	protected function get_sql_clauses() {
		/*
		 * $queries are passed by reference to get_sql_for_query() for recursion.
		 * To keep $this-&gt;queries unaltered, pass a copy.
		 */
		$queries = $this-&gt;queries;
		$sql     = $this-&gt;get_sql_for_query( $queries );

		if ( ! empty( $sql['where'] ) ) {
			$sql['where'] = ' AND ' . $sql['where'];
		}

		return $sql;
	}

	/**
	 * Generates SQL clauses for a single query array.
	 *
	 * If nested subqueries are found, this method recurses the tree to
	 * produce the properly nested SQL.
	 *
	 * @since 4.1.0
	 *
	 * @param array $query Query to parse (passed by reference).
	 * @param int   $depth Optional. Number of tree levels deep we currently are.
	 *                     Used to calculate indentation. Default 0.
	 * @return string[] {
	 *     Array containing JOIN and WHERE SQL clauses to append to a single query array.
	 *
	 *     @type string $join  SQL fragment to append to the main JOIN clause.
	 *     @type string $where SQL fragment to append to the main WHERE clause.
	 * }
	 */
	protected function get_sql_for_query( &amp;$query, $depth = 0 ) {
		$sql_chunks = array(
			'join'  =&gt; array(),
			'where' =&gt; array(),
		);

		$sql = array(
			'join'  =&gt; '',
			'where' =&gt; '',
		);

		$indent = '';
		for ( $i = 0; $i &lt; $depth; $i++ ) {
			$indent .= '  ';
		}

		foreach ( $query as $key =&gt; &amp;$clause ) {
			if ( 'relation' === $key ) {
				$relation = $query['relation'];
			} elseif ( is_array( $clause ) ) {

				// This is a first-order clause.
				if ( $this-&gt;is_first_order_clause( $clause ) ) {
					$clause_sql = $this-&gt;get_sql_for_clause( $clause, $query, $key );

					$where_count = count( $clause_sql['where'] );
					if ( ! $where_count ) {
						$sql_chunks['where'][] = '';
					} elseif ( 1 === $where_count ) {
						$sql_chunks['where'][] = $clause_sql['where'][0];
					} else {
						$sql_chunks['where'][] = '( ' . implode( ' AND ', $clause_sql['where'] ) . ' )';
					}

					$sql_chunks['join'] = array_merge( $sql_chunks['join'], $clause_sql['join'] );
					// This is a subquery, so we recurse.
				} else {
					$clause_sql = $this-&gt;get_sql_for_query( $clause, $depth + 1 );

					$sql_chunks['where'][] = $clause_sql['where'];
					$sql_chunks['join'][]  = $clause_sql['join'];
				}
			}
		}

		// Filter to remove empties.
		$sql_chunks['join']  = array_filter( $sql_chunks['join'] );
		$sql_chunks['where'] = array_filter( $sql_chunks['where'] );

		if ( empty( $relation ) ) {
			$relation = 'AND';
		}

		// Filter duplicate JOIN clauses and combine into a single string.
		if ( ! empty( $sql_chunks['join'] ) ) {
			$sql['join'] = implode( ' ', array_unique( $sql_chunks['join'] ) );
		}

		// Generate a single WHERE clause with proper brackets and indentation.
		if ( ! empty( $sql_chunks['where'] ) ) {
			$sql['where'] = '( ' . "\n  " . $indent . implode( ' ' . "\n  " . $indent . $relation . ' ' . "\n  " . $indent, $sql_chunks['where'] ) . "\n" . $indent . ')';
		}

		return $sql;
	}

	/**
	 * Generates SQL JOIN and WHERE clauses for a first-order query clause.
	 *
	 * "First-order" means that it's an array with a 'key' or 'value'.
	 *
	 * @since 4.1.0
	 *
	 * @global wpdb $wpdb WordPress database abstraction object.
	 *
	 * @param array  $clause       Query clause (passed by reference).
	 * @param array  $parent_query Parent query array.
	 * @param string $clause_key   Optional. The array key used to name the clause in the original `$meta_query`
	 *                             parameters. If not provided, a key will be generated automatically.
	 *                             Default empty string.
	 * @return array {
	 *     Array containing JOIN and WHERE SQL clauses to append to a first-order query.
	 *
	 *     @type string[] $join  Array of SQL fragments to append to the main JOIN clause.
	 *     @type string[] $where Array of SQL fragments to append to the main WHERE clause.
	 * }
	 */
	public function get_sql_for_clause( &amp;$clause, $parent_query, $clause_key = '' ) {
		global $wpdb;

		$sql_chunks = array(
			'where' =&gt; array(),
			'join'  =&gt; array(),
		);

		if ( isset( $clause['compare'] ) ) {
			$clause['compare'] = strtoupper( $clause['compare'] );
		} else {
			$clause['compare'] = isset( $clause['value'] ) &amp;&amp; is_array( $clause['value'] ) ? 'IN' : '=';
		}

		$non_numeric_operators = array(
			'=',
			'!=',
			'LIKE',
			'NOT LIKE',
			'IN',
			'NOT IN',
			'EXISTS',
			'NOT EXISTS',
			'RLIKE',
			'REGEXP',
			'NOT REGEXP',
		);

		$numeric_operators = array(
			'&gt;',
			'&gt;=',
			'&lt;',
			'&lt;=',
			'BETWEEN',
			'NOT BETWEEN',
		);

		if ( ! in_array( $clause['compare'], $non_numeric_operators, true ) &amp;&amp; ! in_array( $clause['compare'], $numeric_operators, true ) ) {
			$clause['compare'] = '=';
		}

		if ( isset( $clause['compare_key'] ) ) {
			$clause['compare_key'] = strtoupper( $clause['compare_key'] );
		} else {
			$clause['compare_key'] = isset( $clause['key'] ) &amp;&amp; is_array( $clause['key'] ) ? 'IN' : '=';
		}

		if ( ! in_array( $clause['compare_key'], $non_numeric_operators, true ) ) {
			$clause['compare_key'] = '=';
		}

		$meta_compare     = $clause['compare'];
		$meta_compare_key = $clause['compare_key'];

		// First build the JOIN clause, if one is required.
		$join = '';

		// We prefer to avoid joins if possible. Look for an existing join compatible with this clause.
		$alias = $this-&gt;find_compatible_table_alias( $clause, $parent_query );
		if ( false === $alias ) {
			$i     = count( $this-&gt;table_aliases );
			$alias = $i ? 'mt' . $i : $this-&gt;meta_table;

			// JOIN clauses for NOT EXISTS have their own syntax.
			if ( 'NOT EXISTS' === $meta_compare ) {
				$join .= " LEFT JOIN $this-&gt;meta_table";
				$join .= $i ? " AS $alias" : '';

				if ( 'LIKE' === $meta_compare_key ) {
					$join .= $wpdb-&gt;prepare( " ON ( $this-&gt;primary_table.$this-&gt;primary_id_column = $alias.$this-&gt;meta_id_column AND $alias.meta_key LIKE %s )", '%' . $wpdb-&gt;esc_like( $clause['key'] ) . '%' );
				} else {
					$join .= $wpdb-&gt;prepare( " ON ( $this-&gt;primary_table.$this-&gt;primary_id_column = $alias.$this-&gt;meta_id_column AND $alias.meta_key = %s )", $clause['key'] );
				}

				// All other JOIN clauses.
			} else {
				$join .= " INNER JOIN $this-&gt;meta_table";
				$join .= $i ? " AS $alias" : '';
				$join .= " ON ( $this-&gt;primary_table.$this-&gt;primary_id_column = $alias.$this-&gt;meta_id_column )";
			}

			$this-&gt;table_aliases[] = $alias;
			$sql_chunks['join'][]  = $join;
		}

		// Save the alias to this clause, for future siblings to find.
		$clause['alias'] = $alias;

		// Determine the data type.
		$_meta_type     = isset( $clause['type'] ) ? $clause['type'] : '';
		$meta_type      = $this-&gt;get_cast_for_type( $_meta_type );
		$clause['cast'] = $meta_type;

		// Fallback for clause keys is the table alias. Key must be a string.
		if ( is_int( $clause_key ) || ! $clause_key ) {
			$clause_key = $clause['alias'];
		}

		// Ensure unique clause keys, so none are overwritten.
		$iterator        = 1;
		$clause_key_base = $clause_key;
		while ( isset( $this-&gt;clauses[ $clause_key ] ) ) {
			$clause_key = $clause_key_base . '-' . $iterator;
			++$iterator;
		}

		// Store the clause in our flat array.
		$this-&gt;clauses[ $clause_key ] =&amp; $clause;

		// Next, build the WHERE clause.

		// meta_key.
		if ( array_key_exists( 'key', $clause ) ) {
			if ( 'NOT EXISTS' === $meta_compare ) {
				$sql_chunks['where'][] = $alias . '.' . $this-&gt;meta_id_column . ' IS NULL';
			} else {
				/**
				 * In joined clauses negative operators have to be nested into a
				 * NOT EXISTS clause and flipped, to avoid returning records with
				 * matching post IDs but different meta keys. Here we prepare the
				 * nested clause.
				 */
				if ( in_array( $meta_compare_key, array( '!=', 'NOT IN', 'NOT LIKE', 'NOT EXISTS', 'NOT REGEXP' ), true ) ) {
					// Negative clauses may be reused.
					$i                     = count( $this-&gt;table_aliases );
					$subquery_alias        = $i ? 'mt' . $i : $this-&gt;meta_table;
					$this-&gt;table_aliases[] = $subquery_alias;

					$meta_compare_string_start  = 'NOT EXISTS (';
					$meta_compare_string_start .= "SELECT 1 FROM $wpdb-&gt;postmeta $subquery_alias ";
					$meta_compare_string_start .= "WHERE $subquery_alias.post_ID = $alias.post_ID ";
					$meta_compare_string_end    = 'LIMIT 1';
					$meta_compare_string_end   .= ')';
				}

				switch ( $meta_compare_key ) {
					case '=':
					case 'EXISTS':
						$where = $wpdb-&gt;prepare( "$alias.meta_key = %s", trim( $clause['key'] ) ); // phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared
						break;
					case 'LIKE':
						$meta_compare_value = '%' . $wpdb-&gt;esc_like( trim( $clause['key'] ) ) . '%';
						$where              = $wpdb-&gt;prepare( "$alias.meta_key LIKE %s", $meta_compare_value ); // phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared
						break;
					case 'IN':
						$meta_compare_string = "$alias.meta_key IN (" . substr( str_repeat( ',%s', count( $clause['key'] ) ), 1 ) . ')';
						$where               = $wpdb-&gt;prepare( $meta_compare_string, $clause['key'] ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared
						break;
					case 'RLIKE':
					case 'REGEXP':
						$operator = $meta_compare_key;
						if ( isset( $clause['type_key'] ) &amp;&amp; 'BINARY' === strtoupper( $clause['type_key'] ) ) {
							$cast     = 'BINARY';
							$meta_key = "CAST($alias.meta_key AS BINARY)";
						} else {
							$cast     = '';
							$meta_key = "$alias.meta_key";
						}
						$where = $wpdb-&gt;prepare( "$meta_key $operator $cast %s", trim( $clause['key'] ) ); // phpcs:ignore WordPress.DB.PreparedSQL.InterpolatedNotPrepared
						break;

					case '!=':
					case 'NOT EXISTS':
						$meta_compare_string = $meta_compare_string_start . "AND $subquery_alias.meta_key = %s " . $meta_compare_string_end;
						$where               = $wpdb-&gt;prepare( $meta_compare_string, $clause['key'] ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared
						break;
					case 'NOT LIKE':
						$meta_compare_string = $meta_compare_string_start . "AND $subquery_alias.meta_key LIKE %s " . $meta_compare_string_end;

						$meta_compare_value = '%' . $wpdb-&gt;esc_like( trim( $clause['key'] ) ) . '%';
						$where              = $wpdb-&gt;prepare( $meta_compare_string, $meta_compare_value ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared
						break;
					case 'NOT IN':
						$array_subclause     = '(' . substr( str_repeat( ',%s', count( $clause['key'] ) ), 1 ) . ') ';
						$meta_compare_string = $meta_compare_string_start . "AND $subquery_alias.meta_key IN " . $array_subclause . $meta_compare_string_end;
						$where               = $wpdb-&gt;prepare( $meta_compare_string, $clause['key'] ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared
						break;
					case 'NOT REGEXP':
						$operator = $meta_compare_key;
						if ( isset( $clause['type_key'] ) &amp;&amp; 'BINARY' === strtoupper( $clause['type_key'] ) ) {
							$cast     = 'BINARY';
							$meta_key = "CAST($subquery_alias.meta_key AS BINARY)";
						} else {
							$cast     = '';
							$meta_key = "$subquery_alias.meta_key";
						}

						$meta_compare_string = $meta_compare_string_start . "AND $meta_key REGEXP $cast %s " . $meta_compare_string_end;
						$where               = $wpdb-&gt;prepare( $meta_compare_string, $clause['key'] ); // phpcs:ignore WordPress.DB.PreparedSQL.NotPrepared
						break;
				}

				$sql_chunks['where'][] = $where;
			}
		}

		// meta_value.
		if ( array_key_exists( 'value', $clause ) ) {
			$meta_value = $clause['value'];

			if ( in_array( $meta_compare, array( 'IN', 'NOT IN', 'BETWEEN', 'NOT BETWEEN' ), true ) ) {
				if ( ! is_array( $meta_value ) ) {
					$meta_value = preg_split( '/[,\s]+/', $meta_value );
				}
			} elseif ( is_string( $meta_value ) ) {
				$meta_value = trim( $meta_value );
			}

			switch ( $meta_compare ) {
				case 'IN':
				case 'NOT IN':
					$meta_compare_string = '(' . substr( str_repeat( ',%s', count( $meta_value ) ), 1 ) . ')';
					$where               = $wpdb-&gt;prepare( $meta_compare_string, $meta_value );
					break;

				case 'BETWEEN':
				case 'NOT BETWEEN':
					$where = $wpdb-&gt;prepare( '%s AND %s', $meta_value[0], $meta_value[1] );
					break;

				case 'LIKE':
				case 'NOT LIKE':
					$meta_value = '%' . $wpdb-&gt;esc_like( $meta_value ) . '%';
					$where      = $wpdb-&gt;prepare( '%s', $meta_value );
					break;

				// EXISTS with a value is interpreted as '='.
				case 'EXISTS':
					$meta_compare = '=';
					$where        = $wpdb-&gt;prepare( '%s', $meta_value );
					break;

				// 'value' is ignored for NOT EXISTS.
				case 'NOT EXISTS':
					$where = '';
					break;

				default:
					$where = $wpdb-&gt;prepare( '%s', $meta_value );
					break;

			}

			if ( $where ) {
				if ( 'CHAR' === $meta_type ) {
					$sql_chunks['where'][] = "$alias.meta_value {$meta_compare} {$where}";
				} else {
					$sql_chunks['where'][] = "CAST($alias.meta_value AS {$meta_type}) {$meta_compare} {$where}";
				}
			}
		}

		/*
		 * Multiple WHERE clauses (for meta_key and meta_value) should
		 * be joined in parentheses.
		 */
		if ( 1 &lt; count( $sql_chunks['where'] ) ) {
			$sql_chunks['where'] = array( '( ' . implode( ' AND ', $sql_chunks['where'] ) . ' )' );
		}

		return $sql_chunks;
	}

	/**
	 * Gets a flattened list of sanitized meta clauses.
	 *
	 * This array should be used for clause lookup, as when the table alias and CAST type must be determined for
	 * a value of 'orderby' corresponding to a meta clause.
	 *
	 * @since 4.2.0
	 *
	 * @return array Meta clauses.
	 */
	public function get_clauses() {
		return $this-&gt;clauses;
	}

	/**
	 * Identifies an existing table alias that is compatible with the current
	 * query clause.
	 *
	 * We avoid unnecessary table joins by allowing each clause to look for
	 * an existing table alias that is compatible with the query that it
	 * needs to perform.
	 *
	 * An existing alias is compatible if (a) it is a sibling of `$clause`
	 * (ie, it's under the scope of the same relation), and (b) the combination
	 * of operator and relation between the clauses allows for a shared table join.
	 * In the case of WP_Meta_Query, this only applies to 'IN' clauses that are
	 * connected by the relation 'OR'.
	 *
	 * @since 4.1.0
	 *
	 * @param array $clause       Query clause.
	 * @param array $parent_query Parent query of $clause.
	 * @return string|false Table alias if found, otherwise false.
	 */
	protected function find_compatible_table_alias( $clause, $parent_query ) {
		$alias = false;

		foreach ( $parent_query as $sibling ) {
			// If the sibling has no alias yet, there's nothing to check.
			if ( empty( $sibling['alias'] ) ) {
				continue;
			}

			// We're only interested in siblings that are first-order clauses.
			if ( ! is_array( $sibling ) || ! $this-&gt;is_first_order_clause( $sibling ) ) {
				continue;
			}

			$compatible_compares = array();

			// Clauses connected by OR can share joins as long as they have "positive" operators.
			if ( 'OR' === $parent_query['relation'] ) {
				$compatible_compares = array( '=', 'IN', 'BETWEEN', 'LIKE', 'REGEXP', 'RLIKE', '&gt;', '&gt;=', '&lt;', '&lt;=' );

				// Clauses joined by AND with "negative" operators share a join only if they also share a key.
			} elseif ( isset( $sibling['key'] ) &amp;&amp; isset( $clause['key'] ) &amp;&amp; $sibling['key'] === $clause['key'] ) {
				$compatible_compares = array( '!=', 'NOT IN', 'NOT LIKE' );
			}

			$clause_compare  = strtoupper( $clause['compare'] );
			$sibling_compare = strtoupper( $sibling['compare'] );
			if ( in_array( $clause_compare, $compatible_compares, true ) &amp;&amp; in_array( $sibling_compare, $compatible_compares, true ) ) {
				$alias = preg_replace( '/\W/', '_', $sibling['alias'] );
				break;
			}
		}

		/**
		 * Filters the table alias identified as compatible with the current clause.
		 *
		 * @since 4.1.0
		 *
		 * @param string|false  $alias        Table alias, or false if none was found.
		 * @param array         $clause       First-order query clause.
		 * @param array         $parent_query Parent of $clause.
		 * @param WP_Meta_Query $query        WP_Meta_Query object.
		 */
		return apply_filters( 'meta_query_find_compatible_table_alias', $alias, $clause, $parent_query, $this );
	}

	/**
	 * Checks whether the current query has any OR relations.
	 *
	 * In some cases, the presence of an OR relation somewhere in the query will require
	 * the use of a `DISTINCT` or `GROUP BY` keyword in the `SELECT` clause. The current
	 * method can be used in these cases to determine whether such a clause is necessary.
	 *
	 * @since 4.3.0
	 *
	 * @return bool True if the query contains any `OR` relations, otherwise false.
	 */
	public function has_or_relation() {
		return $this-&gt;has_or_relation;
	}
}
</code></pre><p class="wporg-dot-link-list"><a href="https://developer.notmatt.press/reference/files/wp-includes/class-wp-meta-query.php/">View all references</a> <a href="https://core.trac.wordpress.org/browser/tags/6.7/src/wp-includes/class-wp-meta-query.php#L23">View on Trac</a> <a href="https://github.com/WordPress/wordpress-develop/blob/6.7/src/wp-includes/class-wp-meta-query.php#L23-L890">View on GitHub</a></p></section>
<section class="wp-block-wporg-code-reference-changelog"><h2 class="is-toc-heading wp-block-heading has-heading-5-font-size" id="changelog" tabindex="-1"><a href="#changelog">Changelog</a></h2> <section class="wp-block-wporg-code-table" style="margin-top:var(--wp--preset--spacing--20);"><figure class="wp-block-table"><table><thead><tr><th scope="col">Version</th><th scope="col">Description</th></tr></thead><tbody><tr class=""><td><a href="https://developer.notmatt.press/reference/since/3.2.0/">3.2.0</a></td><td>Introduced.</td></tr></tbody></table></figure></section> </section>
<section class="wp-block-wporg-code-reference-comments" data-nosnippet="true"><h2 class="is-toc-heading wp-block-heading" id="user-contributed-notes" tabindex="-1"><a href="#user-contributed-notes">User Contributed Notes</a></h2> <ol class="comment-list"> <li class="comment byuser comment-author-sagarprajapati even thread-even depth-1" data-comment-id="1989" id="comment-1989">
<article class="comment-body" id="div-comment-1989">
<a class="screen-reader-text" href="#comment-content-1989">Skip to note 11 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-1989">
<p>In this case, you pass an array of key/value pair arrays (which were described above in the meta_query argument).</p>
<p>You can optionally pass the `relation` key and set it to either OR or AND. It defines the relation, when there is more than one meta query (whether all of the conditions should be met, or at least one of them needs to be met).</p>
<p>Nested arrays can be used to construct complex queries. For example, where _my_custom_key = value OR (_my_custom_key_2 = value AND _my_custom_key_3 = value).</p>
<pre class="wp-block-code"><code class="language-php line-numbers" lang="php">$meta_query_args = array(
	'relation' =&gt; 'OR', // Optional, defaults to "AND"
	array(
		'key'     =&gt; '_my_custom_key',
		'value'   =&gt; 'Value I am looking for',
		'compare' =&gt; '='
	),
	array(
		'relation' =&gt; 'AND',
		array(
			'key'     =&gt; '_my_custom_key_2',
			'value'   =&gt; 'Value I am looking for 2',
			'compare' =&gt; '='
		),
		array(
			'key'     =&gt; '_my_custom_key_3',
			'value'   =&gt; 'Value I am looking for 3',
			'compare' =&gt; '='
		)
	)
);
$meta_query = new WP_Meta_Query( $meta_query_args );</code></pre>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="0" id="feedback-1989">
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
<li class="comment byuser comment-author-sagarprajapati odd alt thread-odd thread-alt depth-1" data-comment-id="1988" id="comment-1988">
<article class="comment-body" id="div-comment-1988">
<a class="screen-reader-text" href="#comment-content-1988">Skip to note 12 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-1988">
<p><strong>Passing an Array of query parameters to the constructor:</strong></p>
<pre class="wp-block-code"><code class="language-php line-numbers" lang="php">$meta_query_args = array(
	'relation' =&gt; 'OR', // Optional, defaults to "AND"
	array(
		'key'     =&gt; '_my_custom_key',
		'value'   =&gt; 'Value I am looking for',
		'compare' =&gt; '='
	)
);
$meta_query = new WP_Meta_Query( $meta_query_args );</code></pre>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="0" id="feedback-1988">
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
<li class="comment byuser comment-author-willsides even thread-even depth-1" data-comment-id="6277" id="comment-6277">
<article class="comment-body" id="div-comment-6277">
<a class="screen-reader-text" href="#comment-content-6277">Skip to note 13 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-6277">
<p>When using the LIKE comparison, a % character is automatically appended to the beginning and end of the value, so adding these in yourself will likely not work as intended</p>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="0" id="feedback-6277">
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
<li class="comment byuser comment-author-sagarprajapati odd alt thread-odd thread-alt depth-1" data-comment-id="1991" id="comment-1991">
<article class="comment-body" id="div-comment-1991">
<a class="screen-reader-text" href="#comment-content-1991">Skip to note 14 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-1991">
<p><strong>Getting the final SQL</strong></p>
<p>You can retrieve the generated SQL by using the following method.</p>
<pre class="wp-block-code"><code class="language-php line-numbers" lang="php">$mq_sql = $meta_query-&gt;get_sql(
	$type,
	$primary_table,
	$primary_id_column,
	$context = null
);</code></pre>
<p>List of Arguments:</p>
<li><strong>$type’ (string) – Type of meta(post, comment, user).</strong></li>
<li><strong>$primary_table</strong> (string) – The table where we will be looking for rows. You can pass for instance $<a href="https://developer.notmatt.press/reference/classes/wpdb/" rel="class">wpdb</a>-&gt;posts, or the alias name if you are aliasing the table in your SQL query</li>
<li><strong>$primary_id_column</strong> (string) – The column that holds the ID(for posts, it is ID, for comments it is comment_ID and for users is ID).</li>
<li><strong>$context</strong> (object) – Optional – The main query object. It is only used when the result is passed to the get_meta_sql filter.</li>
<p>On failure(for instance – lacking any meta query parameters in the query array), this function will return `false`.</p>
<p>On success, it will return an array like this:</p>
<pre class="wp-block-code"><code class="language-php" lang="php">array(
	'join'  =&gt; $join_sql,
	'where' =&gt; $where_sql
)</code></pre>
<p>With each key holding the SQL for the corresponding section.</p>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="0" id="feedback-1991">
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
<li class="comment byuser comment-author-atachibana even thread-even depth-1" data-comment-id="4187" id="comment-4187">
<article class="comment-body" id="div-comment-4187">
<a class="screen-reader-text" href="#comment-content-4187">Skip to note 15 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-4187">
<p>This is from Codex.<br>
<strong>Named sub-meta queries and multiple orderby arguments</strong></br></p>
<p>Named meta sub-queries are particularly useful when you wish to sort by multiple different meta keys. If you pass the name (key) of your meta sub-query to the orderby array, WordPress will use that sub-query as the orderby parameter. See this example below:</p>
<pre class="wp-block-code"><code class="language-php line-numbers" lang="php">$q = new WP_Query( array(
    'meta_query' =&gt; array(
        'relation' =&gt; 'AND',
        'state_clause' =&gt; array(
            'key' =&gt; 'state',
            'value' =&gt; 'Wisconsin',
        ),
        'city_clause' =&gt; array(
            'key' =&gt; 'city',
            'compare' =&gt; 'EXISTS',
        ), 
    ),
    'orderby' =&gt; array( 
        'city_clause' =&gt; 'ASC',
        'state_clause' =&gt; 'DESC',
    ),
) );</code></pre>
<p>Props cybmeta on WPSE for <a href="http://wordpress.stackexchange.com/a/246358/3687" rel="nofollow ugc">this example</a><br/>
.</p>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="0" id="feedback-4187">
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
<li class="comment byuser comment-author-liammcluckie27 odd alt thread-odd thread-alt depth-1" data-comment-id="5945" id="comment-5945">
<article class="comment-body" id="div-comment-5945">
<a class="screen-reader-text" href="#comment-content-5945">Skip to note 16 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-5945">
<p><strong>meta_query processing decimal positions when comparing BETWEEN</strong></p>
<p>When dealing with the BETWEEN comparison and comparing a float key and value you also need to filter the way WP handles DECIMAL datatypes, otherwise, it will use the default specificity. Filtering the DECIMAL type as required will make the query check the float to the desired decimal place.</p>
<p><code></code></p>
<pre class="wp-block-code"><code class="language-php line-numbers" lang="php">$my_float_value = [48.42268096, 52.78325612];

$meta_query_args = [
	'relation' =&gt; 'AND',
	[
		'key' =&gt; 'my_key_value', // Float e.g 50.55784811
		'value' =&gt; $my_float_value,
		'compare' =&gt; 'BETWEEN',
		'type' =&gt; 'DECIMAL(10,3)'
	],
	[
		'key' =&gt; 'my_key_value',
		'value' =&gt; $my_float_value,
		'compare' =&gt; 'BETWEEN',
		'type' =&gt; 'DECIMAL(10,3)'
	]
];</code></pre>
<p></p>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="0" id="feedback-5945">
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
<li class="comment byuser comment-author-sagarprajapati even thread-even depth-1" data-comment-id="1990" id="comment-1990">
<article class="comment-body" id="div-comment-1990">
<a class="screen-reader-text" href="#comment-content-1990">Skip to note 17 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-1990">
<p><strong>Using the <a href="https://developer.notmatt.press/reference/classes/wp_meta_query/parse_query_vars/" rel="method">WP_Meta_Query::parse_query_vars()</a> ( $query ) method:</strong> You can use this method, if you want to use the simple query args(`meta_key`, `meta_value`, `meta_type`, `meta_compare`), or if you are unsure of the presence of meta query parameters.</p>
<pre class="wp-block-code"><code class="language-php line-numbers" lang="php">// $query_vars can have various contents, so an example is not added here, but you need to have it defined beforehand
$meta_query = new WP_Meta_Query();
// Won't work with an array( 'relation', array( 'key' =&gt; '...' ) )
// as the parse_query_vars() method searches for the `meta_` prefix
$meta_query-&gt;parse_query_vars( array(
	'meta_key' =&gt; 'some_key',
	// etc.
) );</code></pre>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="0" id="feedback-1990">
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
<li class="comment byuser comment-author-sagarprajapati odd alt thread-odd thread-alt depth-1" data-comment-id="1992" id="comment-1992">
<article class="comment-body" id="div-comment-1992">
<a class="screen-reader-text" href="#comment-content-1992">Skip to note 18 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-1992">
<p><strong>Example: Single Meta Entry – Flat array</strong></p>
<p>Query</p>
<pre class="wp-block-code"><code class="language-php line-numbers" lang="php">// Note that this will produce a "key only" query
// If you want a full one, add a meta_value and meta_compare array key/value pair
$query_args = array(
	'meta_key' =&gt; 'some_key_name',
);
$meta_query = new WP_Meta_Query();
$meta_query-&gt;parse_query_vars( $query_args );
$mq = $meta_query-&gt;get_sql(
	'post',
	$wpdb-&gt;posts,
	'ID',
	null
);</code></pre>
<p>Result</p>
<pre class="wp-block-code"><code class="language-php" lang="php">array (size=2)
  'join' =&gt; string ' INNER JOIN wp_postmeta ON (wp_posts.ID = wp_postmeta.post_id)' (length=62)
  'where' =&gt; string ' AND (wp_postmeta.meta_key = 'some_key' )' (length=40)</code></pre>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="0" id="feedback-1992">
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
<li class="comment byuser comment-author-sagarprajapati even thread-even depth-1" data-comment-id="2009" id="comment-2009">
<article class="comment-body" id="div-comment-2009">
<a class="screen-reader-text" href="#comment-content-2009">Skip to note 19 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-2009">
<p><strong>Example: Multiple Meta Entries – Multi dimensional array:</strong></p>
<p>Query:</p>
<pre class="wp-block-code"><code class="language-php line-numbers" lang="php">$query_args = array( 'meta_query' =&gt; array(
	'relation' =&gt; 'OR',
	array(
		'key' =&gt; 'foo_key',
		// 'value' =&gt; 'foo',
		// 'compare' =&gt; 'LIKE',
	),
	array(
		'key' =&gt; 'bar_key',
	),
) );
$meta_query = new WP_Meta_Query();
$meta_query-&gt;parse_query_vars( $query_args );
$mq_sql = $meta_query-&gt;get_sql(
	'post',
	$wpdb-&gt;posts,
	'ID',
	null
);</code></pre>
<p>Result:</p>
<pre class="wp-block-code"><code class="language-php" lang="php">'join' =&gt; string ' INNER JOIN wp_postmeta ON wp_posts.ID = wp_postmeta.post_id' (length=60)
'where' =&gt; string ' AND (wp_postmeta.meta_key = 'foo_key' OR wp_postmeta.meta_key = 'bar_key' )' (length=75)</code></pre>
<p>Note: This example will <strong>not</strong> append a space to the <em>join</em> statement, so you have to do it manually to not crash your query. The same goes for the <em>where</em> statement.</p>
<p>If you’re using the value and compare parts of the <em>meta_query</em> input argument array, then the query string will look something like the following:</p>
<pre class="wp-block-code"><code class="language-php" lang="php">'where' =&gt; string ' AND (wp_postmeta.meta_key = 'foo_key' OR  (mt1.meta_key = 'bar_key' AND CAST(mt1.meta_value AS CHAR) LIKE '%foo%') )'</code></pre>
<p>Keep in mind that mt1 is the alias of the meta table and the <em>join</em> clause will look something like this and therefore use the <em>JOIN</em> <strong>twice</strong>:</p>
<pre class="wp-block-code"><code class="language-php" lang="php">'join' =&gt; string ' INNER JOIN wp_postmeta ON wp_posts.ID = wp_postmeta.post_id INNER JOIN wp_postmeta AS mt1 ON (wp_posts.ID = mt1.post_id)'</code></pre>
<p>Use that in further queries or form inside your posts_clauses, posts_where or posts_join filter callbacks.</p>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="0" id="feedback-2009">
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
<li class="comment byuser comment-author-epeleg odd alt thread-odd thread-alt depth-1" data-comment-id="6724" id="comment-6724">
<article class="comment-body" id="div-comment-6724">
<a class="screen-reader-text" href="#comment-content-6724">Skip to note 20 content</a>

<!-- .comment-metadata -->
<div class="wporg-has-embedded-code comment-content" id="comment-content-6724">
<p>please be aware that at the time of writing ( wordpress 6.3.1 ) using:</p>
<pre class="wp-block-code"><code class="language-php line-numbers" lang="php">array(
	'key'     =&gt; 'some_custom_key',
	'value'   =&gt; Array(),
	'compare' =&gt; 'IN'
),</code></pre>
<p>i.e. checking if a custom field value is IN an empty list of values.<br/>
would just be ignored (i.e. succeed) instead of failing as would be expected by reasonable developers.<br/>
This would mean that for example, if this is the only restriction in a <code>get_posts()</code> call it will return all posts instead of none of them….</p>
<p>see <a href="https://core.trac.wordpress.org/ticket/33341" rel="nofollow ugc">https://core.trac.wordpress.org/ticket/33341</a></p>
</div><!-- .comment-content -->
<section class="wporg-has-embedded-code feedback hide-if-js" data-comment-count="0" id="feedback-6724">
</section><!-- .feedback -->

</article><!-- .comment-body -->
</li>
</ol></section>
</div></div>
    </div>
<footer class="text-center mt-10 py-5">
    <p class="text-sm"><a href="https://notmatt.press">NotMattPress</a>.</p>
</footer>
</body>
</html>
